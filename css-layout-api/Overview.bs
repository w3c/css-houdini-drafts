<pre class='metadata'>
Title:  CSS Layout API Level 1
Status: ED
Group: houdini
ED: https://drafts.css-houdini.org/css-layout-api-1/
Shortname: css-layout-api
Level: 1
Abstract:
Editor: Greg Whitworth, gwhit@microsoft.com, w3cid 69511
Editor: Ian Kilpatrick, ikilpatrick@chromium.org, w3cid 73001
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Former Editor: Shane Stephens, shanestephens@google.com, w3cid 47691
Editor: Robert O'Callahan, robert@ocallahan.org
Editor: Rossen Atanassov, rossen.atanassov@microsoft.com, w3cid 49885
Ignored Terms: LayoutWorklet
Ignored Terms: create a workletglobalscope
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
    padding: .5em;
    border: thin solid #ddd; border-radius: .5em;
    margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
    margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
    margin-bottom: 0;
}
</style>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
spec:css-display-3; type:dfn; text:box
spec:css-display-3; type:value; for:display; text:none
spec:css-display-3; type:value; for:<display-inside>; text:grid
spec:css-display-3; type:value; for:<display-outside>; text:inline
spec:css-pseudo-4; type:selector; text:::after
spec:css-pseudo-4; type:selector; text:::before
spec:css-pseudo-4; type:selector; text:::first-letter
spec:css-pseudo-4; type:selector; text:::first-line
spec:dom; type:dfn; for:/; text:element
spec:infra; type:dfn; text:list
spec:html; type:dfn; for:global object; text:realm
spec:css22; type:property;
    text:max-height
    text:max-width
    text:min-height
    text:min-width
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: InvalidModificationError
    urlPrefix: #dfn-;
        url: throw; text: thrown
    urlPrefix: #idl-;
        text: boolean
        text: DOMException
    url: es-type-mapping; text: converting
    url: es-invoking-callback-functions; text: Invoke
urlPrefix: https://tc39.github.io/ecma262/#sec-; type: dfn;
    text: constructor
    text: Construct
    text: GetMethod
    text: IsArray
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: ecmascript-data-types-and-values; text: type
    url: get-o-p; text: Get
    url: generatorfunction; text: generator function
    url: terms-and-definitions-function; text: function
    urlPrefix: native-error-types-used-in-this-standard-
        text: TypeError
urlPrefix: https://drafts.csswg.org/css-display-3/#; type: dfn
    text: flow layout
urlPrefix: https://drafts.csswg.org/css-sizing/#; type: dfn
    text: intrinsic sizes
urlPrefix: https://drafts.csswg.org/css-break/#; type: dfn
    text: fragmentation break
urlPrefix: https://www.w3.org/TR/CSS21/; type:dfn
    urlPrefix: box.html#;
        url: box-dimensions; text: box model edges
    urlPrefix: visudet.html#;
        text: static position
urlPrefix: https://html.spec.whatwg.org/#; type: dfn
    text: structuredserializeforstorage
    text: structureddeserialize
</pre>

Introduction {#intro}
=====================

<em>This section is not normative.</em>

The layout stage of CSS is responsible for generating and positioning <a>fragments</a> from the
<a>box tree</a>.

This specification describes an API which allows developers to layout a <a>box</a> in response to
computed style and <a>box tree</a> changes.

Layout API Containers {#layout-api-containers}
==============================================

A new <a href="https://www.w3.org/TR/css-values-3/#comb-one">alternative</a> value is added
to the <<display-inside>> production: <code>layout(<<ident>>)</code>.

<dl dfn-for="display" dfn-type=value>
    <dt><dfn>layout()</dfn>
    <dd>
        This value causes an element to generate a <a>layout API container</a> box.
</dl>

A <dfn>layout API container</dfn> is the box generated by an element with a <<display-inside>>
<a>computed value</a> ''layout()''.

A <a>layout API container</a> establishes a new <dfn>layout API formatting context</dfn> for its
contents. This is the same as establishing a block formatting context, except that the layout
provided by the author is used instead of the block layout.
For example, floats do not intrude into the layout API container, and the layout API container's
margins do not collapse with the margins of its contents.

All inflow children of a <a>layout API container</a> are called <dfn>layout API children</dfn> and
are laid out using the auther defined layout.

<a>Layout API containers</a> form a containing block for their contents
<a href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details">exactly like block
containers do</a>. [[!CSS21]]

Note: In a future level of the specification there may be a way to override the containing block
    behaviour.

The 'overflow' property applies to <a>layout API containers</a>. This is discussed in
[[#interaction-overflow]].

As the layout is entirely up to the author, properties which are used in other layout modes (e.g.
flex, block) may not apply. For example an author may not repect the 'margin' property on children.

Layout API Container Painting {#painting}
-----------------------------------------

<a>Layout API Container</a> children paint exactly the same as inline blocks [[!CSS21]], except that
the order in which they are returned from the layout method (via
{{FragmentResultOptions/childFragments}}) is used in place of raw document order, and 'z-index'
values other than ''z-index/auto'' create a stacking context even if 'position' is ''static''.

Box Tree Transformations {#layout-api-box-tree}
-----------------------------------------------

The <a>layout API children</a> can act in different ways depending on the value of <a for="document
layout definition">layout options'</a> {{LayoutOptions/childDisplay}} (set by
<code>layoutOptions</code> on the class).

If the value of <a for="document layout definition">layout options'</a>
{{LayoutOptions/childDisplay}} is <code>"block"</code> the 'display' value of that child is
<a>blockified</a>. This is similar to children of <a>flex containers</a> or <a>grid containers</a>.
See [[!css3-display]].

If the value of <a for="document layout definition">layout options'</a>
{{LayoutOptions/childDisplay}} is <code>"normal"</code>, no <a>blockification</a> occurs. Instead
children with a <<display-outside>> <a>computed value</a> of ''inline'' (a <a>root inline box</a>)
will produce a single {{LayoutFragment}} representing each line when
{{LayoutChild/layoutNextFragment()}} is called.

Note: This allows authors to adjust the available inline size of each line, and position each line
    separately.

Children of a {{LayoutChild}} which represents <a>root inline box</a> also have some additional
transformations.

 - A <a>block-level</a> box inside a <a>inline-level</a> box is <a>inlinified</a> I.e. its
     <<display-outside>> is set to ''inline''.

 - A <a>float</a> inside a <a>inline-level</a> box is not taken out of flow. Instead it must be
     treated as inflow, and be <a>inlinified</a>.

In both of the above cases the children become <a>atomic inlines</a>.

Note: User agents would not perform any "inline splitting" or fragmenting when they encounter a
    <a>block-level</a> box.

<div class="note">
    Note: In the example below "inline-span" would be represented as a single {{LayoutChild}} with
    both "block" and "float" being <a>atomic inlines</a>.
    <pre class="lang-html">
        &lt;span id="inline-span">
          Text
          &lt;div id="block">&lt;/div>
          &lt;div id="float">&lt;/div>
          Text
        &lt;/span>
    </pre>
</div>

Layout API Model and Terminology {#layout-api-model-and-terminology}
====================================================================

This section gives an overview of the Layout API given to authors.

The <dfn>current layout</dfn> is the layout algorithm for the <a>box</a> we are currently performing
layout for.

The <dfn>parent layout</dfn> is the layout algorithm for the <a>box's</a> direct parent, (the layout
algorithm which is requesting the <a>current layout</a> to be performed).

A <dfn>child layout</dfn> is the layout algorithm for a {{LayoutChild}} of the <a>current layout</a>.

Layout Children {#layout-children}
----------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutChild {
    readonly attribute StylePropertyMapReadOnly styleMap;

    IntrinsicSizesRequest intrinsicSizes();
    LayoutFragmentRequest layoutNextFragment(LayoutConstraints constraints, ChildBreakToken breakToken);
};
</pre>

The {{LayoutChild}} has internal slot(s):
    - <dfn attribute for=LayoutChild>\[[box]]</dfn> a CSS <a>box</a>.
    - <dfn attribute for=LayoutChild>\[[styleMap]]</dfn> a {{StylePropertyMapReadOnly}}, this is the
        computed style for the child, it is populated with only the properties listed in
        <code>childInputProperties</code>.

<hr>

A {{LayoutChild}} represents either a CSS generated <a>box</a> before layout has occured. (The box
or boxes will all have a computed value of 'display' that is not ''none'').

The {{LayoutChild}} does not contain any layout information itself (like inline or block size) but
can be used to generate {{LayoutFragment}}s which do contain layout information.

An author cannot construct a {{LayoutChild}} with this API, this happens at a separate stage of the
rendering engine (post style resolution).

A {{LayoutChild}} could be generated by:

 - An <a>element</a>.

 - A <a>root inline box</a>.

 - A <a>::before</a> or <a>::after</a> pseudo-element.

    Note: Other pseudo-elements such as <a>::first-letter</a> or <a>::first-line</a> do not generate
        a {{LayoutChild}} for layout purposes. They are additional styling information for a text
        node.

 - An <a>anonymous box</a>. For example an anonymous box may be inserted as a result of:

    - A text node which has undergone <a>blockification</a>. (Or more generally a <a>root inline
        box</a> which has undergone <a>blockification</a>).

    - An element with ''display: table-cell'' which doesn't have a parent with ''display: table''.

<div class="note">
    Note: As an example the following would be placed into three {{LayoutChild}}ren:
    <pre class="lang-html">
        &lt;style>
          #box::before { content: 'hello!'; }
        &lt;/style>
        <!-- A ::before pseudo-element is inserted here. -->
        &lt;div id="box">A block level box with text.&lt;/div>
        &lt;img src="..." />
    </pre>
</div>

<div class="note">
    Note: As an example the following would be placed into a single {{LayoutChild}} as they share a
    <a>root inline box</a>:
    <pre class="lang-html">
        This is a next node, &lt;span>with some additional styling,
        that may&lt;/span> break over&lt;br>multiple lines.
    </pre>
</div>

Multiple non-<a>atomic inlines</a> are placed within the same {{LayoutChild}} to allow rendering
engines to perform text shaping across element boundaries.

<div class="note">
    Note: As an example the following should produce one {{LayoutFragment}} but is from
    three non-<a>atomic inlines</a>:
    <pre class="lang-html">
        &#x639;&lt;span style="color: blue">&#x639;&lt;/span>&#x639;
    </pre>
</div>

An array of {{LayoutChild}}ren is passed into the layout method which represents the children of the
current box which is being laid out.

<div algorithm>
The <dfn attribute for=LayoutChild>styleMap</dfn>, on getting from a {{LayoutChild}} |this|, the
user agent must perform the following steps:

    1. Return |this|' {{StylePropertyMapReadOnly}} contained in the {{[[styleMap]]}} internal slot.
</div>

<div algorithm>
When the <dfn method for=LayoutChild>layoutNextFragment(|constraints|, |breakToken|)</dfn> method is
called on a {{LayoutChild}} |this|, the user agent must perform the following steps:

    1. Let |request| be a new {{LayoutFragmentRequest}} with internal slot(s):
        - {{LayoutFragmentRequest/[[layoutChild]]}} set to |this|.
        - {{[[layoutConstraints]]}} set to |constraints|.
        - {{[[breakToken]]}} set to |breakToken|.

    2. Return |request|.
</div>

<div algorithm>
When the <dfn method for=LayoutChild>intrinsicSizes()</dfn> method is called on a {{LayoutChild}}
|this|, the user agent must perform the following steps:

    1. Let |request| be a new {{IntrinsicSizesRequest}} with internal slot(s):
          - {{IntrinsicSizesRequest/[[layoutChild]]}} set to |this|.

    2. Return |request|.
</div>

Note: Both {{LayoutChild/layoutNextFragment()}} and {{LayoutChild/intrinsicSizes()}} don't
    synchronously run. See [[#request-objects]] for a full description.

### LayoutChildren and the Box Tree ### {#layout-child-box-tree}

Each <a>box</a> has a <dfn attribute for=box>\[[layoutChildMap]]</dfn> internal slot, which is a
<a>map</a> of {{LayoutWorkletGlobalScope}}s to {{LayoutChild}}ren.

<div algorithm="get a layout child">
When the user agent wants to <dfn>get a layout child</dfn> given |workletGlobalScope|, |name|, and
|box|, it <em>must</em> run the following steps:

    1. Assert that:
        - |box| is currently attached to the <a>box tree</a>.
        - |box|'s <a>containing block</a> is a <a>layout API container</a>.
        - The <a>containing block</a>'s ''layout()'' function's first argument is |name|.

    2. Let |layoutChildMap| be |box|'s {{[[layoutChildMap]]}}.

    3. If |layoutChildMap|[|workletGlobalScope|] does not <a for=map>exist</a>, run the following
        steps:

        1. Let |definition| be the result of <a>get a layout definition</a> given |name|, and
            |workletGlobalScope|.

            Assert that <a>get a layout definition</a> succeeded, and |definition| is not
            <code>"invalid"</code>.

        2. Let |childInputProperties| be |definition|'s <a for="layout definition">child input
            properties</a>.

        3. Let |layoutChild| be a new {{LayoutChild}} with internal slot(s):
            - {{[[box]]}} set to |box|.
            - {{[[styleMap]]}} set to a new {{StylePropertyMapReadOnly}} populated with
                <em>only</em> the <a>computed values</a> for properties listed in
                |childInputProperties|.

        4. <a for=map>Set</a> |layoutChildMap|[|workletGlobalScope|] to |layoutChild|.

    4. Return the result of <a for=map>get</a> |layoutChildMap|[|workletGlobalScope|]
</div>

When a <a>box</a> is inserted into the <a>box tree</a> the user agent <em>may</em> pre-populate the
{{[[layoutChildMap]]}} for all {{LayoutWorkletGlobalScope}}s.

When a <a>box</a> is removed from the <a>box tree</a> the user agent <em>must</em> clear the
{{[[layoutChildMap]]}}.

<div algorithm="update a layout child style">
When the user agent wants to <dfn>update a layout child style</dfn> given |box|, it <em>must</em>
run the following steps:

    1. Assert that:
        - |box| is currently attached to the <a>box tree</a>.

    2. If |box|'s <a>containing block</a> is not a <a>layout API container</a>, abort all these
        steps.

    3. Let |layoutChildMap| be |box|'s {{[[layoutChildMap]]}}.

    4. <a for=map>For each</a> |layoutChild| in |layoutChildMap|:

        1. Let |styleMap| be |layoutChild|'s {{[[styleMap]]}}.

        2. Update |styleMap|'s <a>declarations</a> based on the |box|'s new computed style.
</div>

When the computed style of a <a>box</a> changes the user agent must run the <a>update a layout child
style</a> algorithm.

Layout Fragments {#layout-fragments}
------------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutFragment {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    attribute double inlineOffset;
    attribute double blockOffset;

    readonly attribute any data;

    readonly attribute ChildBreakToken? breakToken;
};
</pre>

The {{LayoutFragment}} has internal slot(s):
    - <dfn attribute for=LayoutFragment>\[[layoutFragmentRequest]]</dfn> a
        {{LayoutFragmentRequest}}, this is the fragment request which generated this fragment.
    - <dfn attribute for=LayoutFragment>\[[generator]]</dfn> the generator which produced this
        fragment.

<hr>

A {{LayoutFragment}} represents a CSS <a>fragment</a> of a {{LayoutChild}} after layout has occurred
on that child. This is produced by the {{LayoutChild/layoutNextFragment()}} method.

The {{LayoutFragment}} has {{LayoutFragment/inlineSize}} and {{LayoutFragment/blockSize}}
attributes, which are set by the respective child's layout algorithm. They represent the <b>border
box</b> size of the CSS <a>fragment</a>, and are relative to the <a>current layout's</a> writing
mode.

The {{LayoutFragment/inlineSize}} and {{LayoutFragment/blockSize}} attributes cannot be changed. If
the <a>current layout</a> requires a different {{LayoutFragment/inlineSize}} or
{{LayoutFragment/blockSize}} the author must perform {{LayoutChild/layoutNextFragment()}} again with
different arguments in order to get different results.

The author inside the current layout can position a resulting {{LayoutFragment}} by setting its
{{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}} attributes. If not set by the
author they default to zero. The {{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}}
attributes represent the position of the {{LayoutFragment}} relative to its parent's <b>border
box</b>, before transform or positioning (e.g. if a fragment is <a>relatively positioned</a>) has
been applied.

<div class="example">
The layout algorithm performs a block-like layout (positioning fragments sequentially in the block
direction), while centering its children in the inline direction.

<pre class="lang-javascript">
registerLayout('block-like', class {
    *intrinsicSizes(children, edges, styleMap) {
      const childrenSizes = yield children.map((child) => {
          return child.intrinsicSizes();
      });

      const maxContentSize = childrenSizes.reduce((max, childSizes) => {
          return Math.max(max, childSizes.maxContentSize);
      }, 0) + edges.all.inline;

      const minContentSize = childrenSizes.reduce((max, childSizes) => {
          return Math.max(max, childSizes.minContentSize);
      }, 0) + edges.all.inline;

      return {maxContentSize, minContentSize};
    }

    *layout(children, edges, constraints, styleMap) {
        const availableInlineSize = constraints.fixedInlineSize - edges.all.inline;
        const availableBlockSize = (constraints.fixedBlockSize || Infinity) - edges.all.block;

        const childFragments = [];
        const childConstraints = { availableInlineSize, availableBlockSize };

        const childFragments = yield children.map((child) => {
            return child.layoutNextFragment(childConstraints);
        });

        let blockOffset = edges.all.blockStart;
        for (let fragment of childFragments) {
            // Position the fragment in a block like manner, centering it in the
            // inline direction.
            fragment.blockOffset = blockOffset;
            fragment.inlineOffset = Math.max(
                edges.all.inlineStart,
                (availableInlineSize - fragment.inlineSize) / 2);

            blockOffset += fragment.blockSize;
        }

        const autoBlockSize = blockOffset + edges.all.blockEnd;

        return {
            autoBlockSize,
            childFragments,
        };
    }
});
</pre>
</div>

A <a>layout API container</a> can communicate with other <a>layout API containers</a> by using the
{{LayoutFragment/data}} attribute. This is set by the {{FragmentResultOptions/data}} member in the
{{FragmentResultOptions}} dictionary.

The {{LayoutFragment}}'s {{LayoutFragment/breakToken}} specifies where the {{LayoutChild}} last
fragmented. If the {{LayoutFragment/breakToken}} is null the {{LayoutChild}} wont produce any more
{{LayoutFragment}}s for that token chain. The {{LayoutFragment/breakToken}} can be passed to the
{{LayoutChild/layoutNextFragment()}} function to produce the next {{LayoutFragment}} for a
particular child. The {{LayoutFragment/breakToken}} cannot be changed.
If the <a>current layout</a> requires a different {{LayoutFragment/breakToken}} the author must perform
{{LayoutChild/layoutNextFragment()}} again with different arguments.

<div algorithm>
When the user agent wants to <dfn>create a layout fragment</dfn> given |generator|,
|layoutFragmentRequest|, and |internalFragment|, it <em>must</em> run the following steps:
    1. Let |targetRealm| be |generator|'s <a>Realm</a>.

    2. Let |fragment| be a new {{LayoutFragment}} with:

        - The {{[[layoutFragmentRequest]]}} internal slot being |layoutFragmentRequest|.

        - The {{[[generator]]}} internal slot being |generator|.

        - {{LayoutFragment/inlineSize}} being |internalFragment|'s <a>inline size</a> relative to
            the <a>current layout's</a> writing mode.

        - {{LayoutFragment/blockSize}} being |internalFragment|'s <a>block size</a> relative to the
            <a>current layout's</a> writing mode.

        - {{LayoutFragment/inlineOffset}} initially set to 0.

        - {{LayoutFragment/blockOffset}} initially set to 0.

        - {{LayoutFragment/breakToken}} being a new {{ChildBreakToken}} representing
            |internalFragment|'s internal break token, if any.

        - If |internalFragment| has a |clonedData| object stored with it, let
            {{LayoutFragment/data}} being the result of
            <a>StructuredDeserialize</a>(|clonedData|, |targetRealm|), otherwise null.

    3. Return |fragment|.
</div>

Intrinsic Sizes {#intrinsic-sizes}
----------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface IntrinsicSizes {
  readonly attribute double minContentSize;
  readonly attribute double maxContentSize;
};
</pre>

The {{IntrinsicSizes}} object has internal slot(s):
    - <dfn attribute for=IntrinsicSizes>\[[intrinsicSizesRequest]]</dfn> a
        {{IntrinsicSizesRequest}}, this is the intrinsic sizes request which generated these
        intrinsic sizes.

<hr>

A {{IntrinsicSizes}} object represents the <a>min-content size</a> and <a>max-content size</a> of a
CSS <a>box</a>. It has {{IntrinsicSizes/minContentSize}} and {{IntrinsicSizes/maxContentSize}}
attributes which represent the <b>border box</b> min/max-content contribution of the {{LayoutChild}}
for the <a>current layout</a>. The attributes are relative to the inline direction of the <a>current
layout's</a> writing mode.

The {{IntrinsicSizes/minContentSize}} and {{IntrinsicSizes/maxContentSize}} cannot be changed. They
must not change for a {{LayoutChild}} within the current layout pass.

<div class="example">
The example below shows the border-box intrinsic sizes of two children.

<pre class="lang-html">
&lt;style>
.child-0 {
  width: 380px;
  border: solid 10px;
}

.child-1 {
  border: solid 5px;
}

.box {
  display: layout(intrinsic-sizes-example);
  font: 25px/1 Ahem;
}
&lt;/style>

&lt;div class="box">
  &lt;div class="child-0">&lt;/div>
  &lt;div class="child-1">XXX XXXX&lt;/div>
&lt;/div>
</pre>

<pre class="lang-javascript">
registerLayout('intrinsic-sizes-example', class {
    *intrinsicSizes(children, edges, styleMap) {
      const childrenSizes = yield children.map((child) => {
          return child.intrinsicSizes();
      });

      childrenSizes[0].minContentSize; // 400, (380+10+10) child has a fixed size.
      childrenSizes[0].maxContentSize; // 400, (380+10+10) child has a fixed size.

      childrenSizes[1].minContentSize; // 100, size of "XXXX".
      childrenSizes[1].maxContentSize; // 200, size of "XXX XXXX".
    }

    *layout() {}
});
</pre>
</div>

<div algorithm>
When the user agent wants to <dfn>create an intrinsic sizes object</dfn> given
|intrinsicSizesRequest|, and |internalIntrinsicSizes|, it <em>must</em> run the following steps:

    1. Let |intrinsicSizes| be a new {{IntrinsicSizes}} with:

        - The {{[[intrinsicSizesRequest]]}} internal slot being |intrinsicSizesRequest|.

        - {{IntrinsicSizes/minContentSize}} being |internalIntrinsicSizes|' <b>border box</b>
            min-content contribution, relative to the <a>current layout's</a> writing mode.

        - {{IntrinsicSizes/maxContentSize}} being |internalIntrinsicSizes|'s <b>border box</b>
            max-content contribution, relative to the <a>current layout's</a> writing mode.

    2. Return |intrinsicSizes|.
</div>

Layout Constraints {#layout-constraints}
----------------------------------------

<pre class='idl'>
[Constructor(optional LayoutConstraintsOptions options),Exposed=LayoutWorklet]
interface LayoutConstraints {
    readonly attribute double availableInlineSize;
    readonly attribute double availableBlockSize;

    readonly attribute double? fixedInlineSize;
    readonly attribute double? fixedBlockSize;

    readonly attribute double percentageInlineSize;
    readonly attribute double percentageBlockSize;

    readonly attribute double? blockFragmentationOffset;
    readonly attribute BlockFragmentationType blockFragmentationType;

    readonly attribute any data;
};

dictionary LayoutConstraintsOptions {
    double availableInlineSize = 0;
    double availableBlockSize = 0;

    double fixedInlineSize;
    double fixedBlockSize;

    double percentageInlineSize;
    double percentageBlockSize;

    double blockFragmentationOffset;
    BlockFragmentationType blockFragmentationType = "none";

    any data;
};

enum BlockFragmentationType { "none", "page", "column", "region" };
</pre>

A {{LayoutConstraints}} object is passed into the layout method which represents the all the
constraints for the <a>current layout</a> to perform layout inside. It is also used to pass
information about the available space into a <a>child layout</a>.

The {{LayoutConstraints}} object has {{LayoutConstraints/availableInlineSize}} and
{{LayoutConstraints/availableBlockSize}} attributes. This represents the <a>available space</a> for
a {{LayoutFragment}} which the layout should respect.

Note: Some layouts may need to produce a {{LayoutFragment}} which exceed this size. For example a
    <a>replaced element</a>. The <a>parent layout</a> should expect this to occur and deal with it
    appropriately.

A <a>parent layout</a> may require the <a>current layout</a> to be exactly a particular size. If
the {{LayoutConstraints/fixedInlineSize}} or {{LayoutConstraints/fixedBlockSize}} are specified the
<a>current layout</a> should produce a {{LayoutFragment}} with a the specified size in the
appropriate direction.

<div class="example">
The layout algorithm performs a flexbox-like distribution of spare space in the inline direction. It
creates child layout constraints which specify that a child should be a fixed inline size.

<pre class="lang-javascript">
registerLayout('flex-distribution-like', class {
    *intrinsicSizes(children, edges, styleMap) {
      const childrenSizes = yield children.map((child) => {
          return child.intrinsicSizes();
      });

      const maxContentSize = childrenSizes.reduce((sum, childSizes) => {
          return sum + childSizes.maxContentSize;
      }, 0) + edges.all.inline;

      const minContentSize = childrenSizes.reduce((max, childSizes) => {
          return sum + childSizes.minContentSize;
      }, 0) + edges.all.inline;

      return {maxContentSize, minContentSize};
    }

    *layout(children, edges, constraints, styleMap) {

        const availableInlineSize =
            constraints.fixedInlineSize - edges.all.inline;
        const availableBlockSize =
            (constraints.fixedInlineSize || Infinity) - edges.all.block;

        const childConstraints = { availableInlineSize, availableBlockSize };

        const unconstrainedChildFragments = yield children.map((child) => {
            return child.layoutNextFragment(childConstraints);
        });

        const unconstrainedSizes = [];
        const totalSize = unconstrainedChildFragments.reduce((sum, fragment, i) => {
            unconstrainedSizes[i] = fragment.inlineSize;
            return sum + fragment.inlineSize;
        }, 0);

        // Distribute spare space between children.
        const remainingSpace = Math.max(0, inlineSize - totalSize);
        const extraSpace = remainingSpace / children.length;

        const childFragments = yield children.map((child, i) => {
            return child.layoutNextFragment({
                fixedInlineSize: unconstrainedSizes[i] + extraSpace,
                availableBlockSize
            });
        });

        // Position the fragments.
        let inlineOffset = 0;
        let maxChildBlockSize = 0;
        for (let fragment of childFragments) {
            fragment.inlineOffset = inlineOffset;
            fragment.blockOffset = edges.all.blockStart;

            inlineOffset += fragment.inlineSize;
            maxChildBlockSize = Math.max(maxChildBlockSize, fragment.blockSize);
        }

        return {
            autoBlockSize: maxChildBlockSize + edges.all.block,
            childFragments,
        };
    }
});
</pre>
</div>

The {{LayoutConstraints}} object has {{LayoutConstraints/percentageInlineSize}} and
{{LayoutConstraints/percentageBlockSize}} attributes. These represent the size that a layout
percentages should be resolved against while performing layout.

The {{LayoutConstraints}} has a {{LayoutConstraints/blockFragmentationType}} attribute. The
<a>current layout</a> should produce a {{LayoutFragment}} which fragments at the
{{LayoutConstraints/blockFragmentationOffset}} if possible.

The <a>current layout</a> can choose not to fragment a {{LayoutChild}} based on the
{{LayoutConstraints/blockFragmentationType}}, for example if the child has a property like
''break-inside: avoid-page;''.

<div algorithm>
When the user agent wants to <dfn>create a layout constraints object</dfn> given |sizingMode|, box|,
and |internalLayoutConstraints|, it <em>must</em> run the following steps:

    1. If |sizingMode| is <code>"block-like"</code> then:

        1. Let |fixedInlineSize| be the result of calculating |box|'s <b>border-box</b>
            <a>inline size</a> (relative to |box|'s writing mode) exactly like block containers do.

        2. Let |fixedBlockSize| be null if |box|'s <a>block size</a> is ''height/auto'', otherwise
            the result of calculating |box|'s <b>border-box</b> <a>block size</a> exactly like block
            containers do.

        3. Return a new {{LayoutConstraints}} object with:

            - {{LayoutConstraints/fixedInlineSize}}, and {{LayoutConstraints/availableInlineSize}}
                set to |fixedInlineSize|.

            - {{LayoutConstraints/percentageInlineSize}} set to |internalLayoutConstraints|'
                percentage resolution size in the inline axis (relative to |box|'s writing mode).

            - {{LayoutConstraints/fixedBlockSize}} set to |fixedBlockSize|.

            - {{LayoutConstraints/availableBlockSize}} set to |fixedBlockSize| if not null,
                otherwise |internalLayoutConstraints|' <a>available space</a> in the block axis
                (relative to |box|'s writing mode).

            - {{LayoutConstraints/percentageBlockSize}} set to |internalLayoutConstraints|'
                percentage resolution size in the block axis (relative to |box|'s writing mode).

    2. If |sizingMode| is <code>"manual"</code> then:

        1. Return a new {{LayoutConstraints}} object with:
            - {{LayoutConstraints/fixedInlineSize}}/{{LayoutConstraints/fixedBlockSize}} set to
                |internalLayoutConstraints|' fixed inline/block size (relative to |box|'s writing
                mode) imposed by the <a>parent layout</a>. Either may be null.

                Note: See [[#interaction-sizing]] for different scenarios when this can occur.

            - {{LayoutConstraints/availableInlineSize}}/{{LayoutConstraints/availableBlockSize}} set
                to |internalLayoutConstraints|' <a>available space</a>.

            - {{LayoutConstraints/percentageInlineSize}}/{{LayoutConstraints/percentageBlockSize}}
                set to |internalLayoutConstraints|' percentage resolution size.
</div>

Breaking and Fragmentation {#breaking-and-fragmentation}
--------------------------------------------------------

<pre class="idl">
[Exposed=LayoutWorklet]
interface ChildBreakToken {
    readonly attribute BreakType breakType;
    readonly attribute LayoutChild child;
};

[Exposed=LayoutWorklet]
interface BreakToken {
    readonly attribute sequence&lt;ChildBreakToken> childBreakTokens;
    readonly attribute any data;
};

dictionary BreakTokenOptions {
    sequence&lt;ChildBreakToken> childBreakTokens;
    any data = null;
};

enum BreakType { "none", "line", "column", "page", "region" };
</pre>

A {{LayoutChild}} can produce multiple {{LayoutFragment}}s. A {{LayoutChild}} may fragment in the
block direction if a {{LayoutConstraints/blockFragmentationType}} is not none.  Additionally
{{LayoutChild}} which represents <a>inline-level</a> content, may fragment line by line if the
<a for="document layout definition">layout options'</a> {{LayoutOptions/childDisplay}} (set by
<code>layoutOptions</code>) is <code>"normal"</code>.

A subsequent {{LayoutFragment}} is produced by using the previous {{LayoutFragment}}'s
{{LayoutFragment/breakToken}}. This tells the <a>child layout</a> to produce a {{LayoutFragment}}
starting at the point encoded in the {{ChildBreakToken}}.

<div class="example">
This example shows a simple layout which indents child fragments for a certain number of
lines.

This example also demonstrates using the previous {{LayoutFragment/breakToken}} of a
{{LayoutFragment}} to produce the next fragment for the {{LayoutChild}}.

It also demonstrates using the {{BreakToken}} to respect the {{LayoutConstraints}}'
{{LayoutConstraints/blockFragmentationType}}, it resumes it layout from the previous {{BreakToken}}.
It returns a {{FragmentResultOptions}} with a {{FragmentResultOptions/breakToken}} which is used to
resume the layout.

<pre class="lang-javascript">
registerLayout('indent-lines', class {
    static layoutOptions = {childDisplay: 'normal'};
    static inputProperties = ['--indent', '--indent-lines'];

    *layout(children, edges, constraints, styleMap, breakToken) {

        // Determine our (inner) available size.
        const availableInlineSize =
            constraints.fixedInlineSize - edges.all.inline;
        const availableBlockSize =
            (constraints.fixedBlockSize || Infinity) - edges.all.block;

        // Detrermine the number of lines to indent, and the indent amount.
        const indent = resolveLength(constraints, styleMap.get('--indent'));
        let lines = styleMap.get('--indent-lines').value;

        const childFragments = [];

        let childBreakToken = null;
        if (breakToken) {
            childBreakToken = breakToken.childBreakTokens[0];

            // Remove all the children we have already produced fragments for.
            children.splice(0, children.indexOf(childBreakToken.child));
        }

        let blockOffset = edges.all.blockStart;
        let child = children.shift();
        while (child) {
            const shouldIndent = lines-- > 0;

            // Adjust the inline size for the indent.
            const childAvailableInlineSize = shouldIndent ?
                availableInlineSize - indent : availableInlineSize;

            const childConstraints = {
                availableInlineSize: childAvailableInlineSize,
                availableBlockSize,
                percentageInlineSize: availableInlineSize,
                blockFragmentationType: constraints.blockFragmentationType,
            };

            const fragment = yield child.layoutNextFragment(childConstraints,
                                                            childBreakToken);
            childFragments.push(fragment);

            // Position the fragment.
            fragment.inlineOffset = shouldIndent ?
                edges.all.inlineStart + indent : edges.all.inlineStart;
            fragment.blockOffset = blockOffset;
            blockOffset += fragment.blockSize;

            // Check if we have gone over the block fragmentation limit.
            if (constraints.blockFragmentationType != 'none' &&
                blockOffset > constraints.blockSize) {
                break;
            }

            if (fragment.breakToken) {
                childBreakToken = fragment.breakToken;
            } else {
                // If a fragment doesn't have a break token, we move onto the
                // next child.
                child = children.shift();
                childBreakToken = null;
            }
        }

        const autoBlockSize = blockOffset + edges.all.blockEnd;

        // Return our fragment.
        const result = {
            autoBlockSize,
            childFragments: childFragments,
        }

        if (childBreakToken) {
            result.breakToken = {
                childBreakTokens: [childBreakToken],
            };
        }

        return result;
    }
});
</pre>
</div>

Edges {#edges}
--------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutEdgeSizes {
  readonly attribute double inlineStart;
  readonly attribute double inlineEnd;

  readonly attribute double blockStart;
  readonly attribute double blockEnd;

  // Convenience attributes for the sum in one direction.
  readonly attribute double inline;
  readonly attribute double block;
};

[Exposed=LayoutWorklet]
interface LayoutEdges {
  readonly attribute LayoutEdgeSizes border;
  readonly attribute LayoutEdgeSizes scrollbar;
  readonly attribute LayoutEdgeSizes padding;

  readonly attribute LayoutEdgeSizes all;
};
</pre>

A {{LayoutEdges}} object is passed into the layout method. This represents the size of the <a>box
model edges</a> for the current box which is being laid out.

The {{LayoutEdges}} has {{LayoutEdges/border}}, {{LayoutEdges/scrollbar}}, and
{{LayoutEdges/padding}} attributes. Each of these represent the width of their respective edge.

The {{LayoutEdges}} has the {{LayoutEdges/all}} attribute. This is a convenience attribute which
represents the sum of the {{LayoutEdges/border}}, {{LayoutEdges/scrollbar}}, {{LayoutEdges/padding}}
edges.

The {{LayoutEdgeSizes}} object represents the width in CSS pixels of an edge in each of the
<a>abstract dimensions</a> ({{LayoutEdgeSizes/inlineStart}}, {{LayoutEdgeSizes/inlineEnd}},
{{LayoutEdgeSizes/blockStart}}, {{LayoutEdgeSizes/blockEnd}}).

The {{LayoutEdgeSizes/inline}}, and {{LayoutEdgeSizes/block}} on the {{LayoutEdgeSizes}} object are
convenience attributes which represent the sum in that direction.

<div class="example">
This example shows an node styled by CSS, and what its respective {{LayoutEdges}} could contain.

<pre class="lang-html">
&lt;style>
.container {
  width: 50px;
  height: 50px;
}

.box {
  display: layout(box-edges);

  padding: 10%;
  border: solid 2px;
  overflow-y: scroll;
}
&lt;/style>

&lt;div class="container">
  &lt;div class="box">&lt;/div>
&lt;/div>
</pre>

<pre class="lang-javascript">
registerLayout('box-edges', class {
    *layout(children, edges, constraints, styleMap, breakToken) {
        edges.padding.inlineStart; // 5 (as 10% * 50px = 5px).
        edges.border.blockEnd; // 2
        edges.scrollbar.inlineEnd; // UA-dependent, may be 0 or >0 (e.g. 16).
        edges.all.block; // 14 (2 + 5 + 5 + 2).
    }
}
</pre>
</div>

Interactions with other Modules {#interactions-with-other-modules}
==================================================================

This section describes how other CSS modules interact with the CSS Layout API.

Sizing {#interaction-sizing}
----------------------------

User agents must use the {{LayoutConstraints}} object to communicate to the <a>current layout</a>
the size they would like the fragment to be.

If the user agent wishes to force a size on the box, it can use the
{{LayoutConstraints/fixedInlineSize}} and {{LayoutConstraints/fixedBlockSize}} attributes to do so.

The <a>layout API container</a> can be passed size information in different ways depending on the
value of <a for="document layout definition">layout options'</a> {{LayoutOptions/sizing}} (set by
<code>layoutOptions</code> on the class).

If the value of <a for="document layout definition">layout options'</a> {{LayoutOptions/sizing}} is
<code>"block-like"</code>, then the {{LayoutConstraints}} passed to the <a>layout API container</a>:
    - <em>Must</em> calculate and set {{LayoutConstraints/fixedInlineSize}} based off the rules
        specified in [[!css-sizing-3]] and the formatting context in which it participates, e.g.

        - As a <a>block-level</a> box in a <a>block formatting context</a>, it is sized like a
            <a>block box</a> that establishes a formatting context, with an ''width/auto'' <a>inline
            size</a> calculated as for non-replaced block boxes.

        - As an <a>inline-level</a> box in an <a>inline formatting context</a>, it is sized as an
            atomic inline-level box (such as an inline-block).

    - <em>Must</em> calculate and set {{LayoutConstraints/fixedBlockSize}} based off the rules
        specified in [[!css-sizing-3]], and the formatting context in which it participates. If the
        <a>layout API container</a> has an ''height/auto'' <a>block size</a>, and cannot be determined
        ahead of time, {{LayoutConstraints/fixedBlockSize}} must be set to <code>null</code>.

If the value of <a for="document layout definition">layout options'</a> {{LayoutOptions/sizing}} is
<code>"manual"</code>, then the user-agent must not pre-calculate
{{LayoutConstraints/fixedInlineSize}} and/or {{LayoutConstraints/fixedBlockSize}} ahead of time,
except when it is being forced to a particular size by the formatting context in which it
participates, for example:

    - If the <a>layout API container</a> is within a <a>block formatting context</a>, is inflow, and
        has an ''width/auto'' inline size, the user agent <em>must</em> set the
        {{LayoutConstraints/fixedInlineSize}} to the <a>stretch-fit inline size</a>.

<div class="note">
    Note: In the example below the <a>layout API container</a> has its inline size set to 50.

    <pre class="lang-html">
        &lt;style>
          #container {
            width: 100px;
            height: 100px;
            box-sizing: border-box;
            padding: 5px;
          }
          #layout-api {
            display: layout(foo);
            margin: 0 20px;
          }
        &lt;/style>
        &lt;div id="container">
          &lt;div id="layout-api">&lt;/div>
        &lt;/div>
    </pre>
</div>

### Positioned layout sizing ### {#interaction-sizing-positiong-layout}

If a <a>layout API container</a> is out-of-flow positioned the user agent <em>must</em> solve the
positioned size equations ([[css-position-3#abs-non-replaced-width]],
[[css-position-3#abs-non-replaced-height]]), and set the appropriate
{{LayoutConstraints/fixedInlineSize}} and {{LayoutConstraints/fixedBlockSize}}.

<div class="note">
    Note: In the example below the <a>layout API container</a> has its inline and block size fixed
        to 80.

    <pre class="lang-html">
        &lt;style>
          #container {
            position: relative;
            width: 100px;
            height: 100px;
          }
          #layout-api {
            display: layout(foo);
            top: 10px;
            bottom: 10px;
            left: 10px;
            right: 10px;
            position: absolute;
          }
        &lt;/style>
        &lt;div id="container">
          &lt;div id="layout-api">&lt;/div>
        &lt;/div>
    </pre>
</div>

Positioning {#interaction-positioning}
--------------------------------------

All positioning in this level of the specification is handled by the user agent.

As a result:
  - Out-of-flow children do not appear as {{LayoutChild}}ren.

  - <a>Layout API containers</a> establish <a>containing blocks</a> <a
      href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details">exactly like block
      containers do</a>. [[!CSS21]]

  - The {{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}} represent the position of
      the fragment before any positioning and transforms have occured.

  - The <a>static position</a> of an absolutely-positioned child of a <a>layout API container</a> is
      set to the <a>inline-start</a>, <a>block-start</a> padding edge of the <a>layout API
      container</a>. Auto margins are treated as zero for the child.

<div class="note">
    Note: In the example below:
      - "child-relative" would be the only child passed to the author's layout. If it was positioned
          at ({{LayoutFragment/inlineOffset}} <code>= 20</code>, {{LayoutFragment/blockOffset}}
          <code> = 30</code>), its final position would be (<code>25</code>, <code>40</code>) as the
          relative positioning was handled by the user agent.

      - "child-absolute" would not appear as a {{LayoutChild}}, and instead would be laid out and
          positioned by the user agent.

      - The examples above also apply in a similar way to sticky and fixed positioned children.

    <pre class="lang-html">
        &lt;style>
          #container {
            display: layout(foo);
            position: relative; /* container is a containing block */
            width: 100px;
            height: 100px;
          }
          #child-relative {
            position: relative;
            left: 5px;
            top: 10px;
          }
        &lt;/style>
        &lt;div id="container">
          &lt;div id="child-relative">&lt;/div>
          &lt;div id="child-absolute">&lt;/div>
        &lt;/div>
    </pre>
</div>

Overflow {#interaction-overflow}
--------------------------------

The <a>scrollable overflow</a> for a <a>layout API container</a> is handled by the user agent in
this level of the specification.

A <a>layout API container</a> should calculate its scrollable overflow exactly like block
containers do.

Even if the author's <a>layout API container</a> positions a fragment into the <a>scrollable
overflow</a> region, relative positioning or transforms may cause the fragment to shift such that
its <a>scrollable overflow</a> region, causing no overflow to occur.

Fragmentation {#interaction-fragmentation}
------------------------------------------

A <a>parent layout</a> can ask the <a>current layout</a> to <a>fragment</a> by setting the
{{LayoutConstraints/blockFragmentationType}} and {{LayoutConstraints/blockFragmentationOffset}}.

E.g. [[css-multicol-1]] layout would set a {{LayoutConstraints/blockFragmentationType}} to
<code>"column"</code> and set the {{LayoutConstraints/blockFragmentationOffset}} to where it needs the
child to fragment.

Alignment {#interaction-alignment}
----------------------------------

The first/last baseline sets of a <a>layout API container</a> is generated exactly like block
containers do (see [[css-align-3#baseline-export]]). Except that the order of the in-flow children
should be determined by the in which they are returned form the layout method (via
{{FragmentResultOptions/childFragments}}) instead of the document order.

<div class="note">
Note: In a future level of the specification there will be the ability for the author to define the
baselines themselves. This will be of the form:

To <em>query</em> baseline information from a {{LayoutChild}}.
<pre class="lang-javascript">
const fragment = yield child.layoutNextFragment({
  fixedInlineSize: availableInlineSize,
  baselineRequests: ['alphabetic', 'middle'],
});
fragment.baselines.get('alphabetic') === 25 /* or something */;
</pre>

To <em>produce</em> baseline information for a <a>parent layout</a>:
<pre class="lang-javascript">
registerLayout('baseline-producing', class {
  *layout(children, edges, constraints, styleMap) {
    const result = {baselines: {}};

    for (let baselineRequest of constraints.baselineRequests) {
      // baselineRequest === 'alphabetic', or something else.
      result.baselines[baselineRequest] = 25;
    }

    return result;
  }
});
</pre>
</div>

Layout {#layout}
================

This section describes how the CSS Layout API interacts with the user agent's layout engine.

Concepts {#concepts}
--------------------

A <dfn>layout definition</dfn> is a <a>struct</a> which describes the information needed by the
{{LayoutWorkletGlobalScope}} about the author defined layout (which can be referenced by the
''layout()'' function). It consists of:

 - <dfn for="layout definition">class constructor</dfn> which is the class <a>constructor</a>.

 - <dfn for="layout definition">layout generator function</dfn> which is the layout <a>generator
     function</a> callback.

 - <dfn for="layout definition">intrinsic sizes generator function</dfn> which is the intrinsic sizes
     <a>generator function</a> callback.

 - <dfn for="layout definition">constructor valid flag</dfn>.

 - <dfn for="layout definition">input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>

 - <dfn for="layout definition">child input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>.

 - <dfn for="layout definition">layout options</dfn> a {{LayoutOptions}}.

A <dfn>document layout definition</dfn> is a <a>struct</a> which describes the information needed by
the <a>document</a> about the author defined layout (which can be referenced by the ''layout()''
function). It consists of:

 - <dfn for="document layout definition">input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>

 - <dfn for="document layout definition">child input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>.

 - <dfn for="document layout definition">layout options</dfn> a {{LayoutOptions}}.

Layout Invalidation {#layout-invalidation}
------------------------------------------

Each <a>box</a> has an associated <dfn>layout valid flag</dfn>. It may be either
<dfn>layout-valid</dfn> or <dfn>layout-invalid</dfn>. It is initially set to <a>layout-invalid</a>.

Each <a>box</a> has an associated <dfn>intrinsic sizes valid flag</dfn>. If may be either
<dfn>intrinsic-sizes-valid</dfn> or <dfn>intrinsic-sizes-invalid</dfn>. It is initially set to
<a>intrinsic-sizes-invalid</a>.

<div algorithm>
When the user agent wants to <dfn>invalidate layout functions</dfn> given |box|, the user agent
<em>must</em> run the following steps:

    1. Let |layoutFunction| be the ''layout()'' function of the 'display' property on the computed
        style for the |box| if it exists. If it is a different type of value (e.g.  ''grid'') then
        abort all these steps.

    2. Let |name| be the first argument of the |layoutFunction|.

    3. Let |documentDefinition| be the result of <a>get a document layout definition</a> given
        |name|.

        If <a>get a document layout definition</a> returned failure, or if |documentDefinition| is
        <code>"invalid"</code>, then abort all these steps.

    4. Let |inputProperties| be |documentDefinition|'s <a for="document layout definition">input
        properties</a>.

    5. Let |childInputProperties| be |documentDefinition|'s <a for="document layout
        definition">child input properties</a>.

    6. For each |property| in |inputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>, and
        set the <a>intrinsic sizes valid flag</a> to <a>intrinsic-sizes-invalid</a>.

    7. For each |property| in |childInputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>, and
        set the <a>intrinsic sizes valid flag</a> to <a>intrinsic-sizes-invalid</a>.
</div>

<a>Invalidate layout functions</a> <em>must</em> be run when the user agent recalculates the computed
style for a box, or when the children's computed style of that box is recalculated.

When a child <a>box</a> represented by a {{LayoutChild}} is added or removed from the <a>box
tree</a> or has its layout invalidated (from a computed style change, or a descendant change),
<em>and</em> this invalidation is to be propagated up the box tree, set the <a>layout valid flag</a>
on the current <a>box</a> to <a>layout-invalid</a> and set the <a>intrinsic sizes valid flag</a> on
the current <a>box</a> to <a>intrinsic-sizes-invalid</a>.

When the computed style of a <a>layout API container</a> changes, <em>and</em> this change effects
the values inside the {{LayoutEdges}} object, set the <a>layout valid flag</a> of the box to
<a>layout-invalid</a>, and set the <a>intrinsic sizes valid flag</a> of the box to
<a>intrinsic-sizes-invalid</a>.

If the computed style changes effects the values inside the {{LayoutConstraints}} object, just set
the <a>intrinsic sizes valid flag</a> of the box to <a>intrinsic-sizes-invalid</a>.

Note: As the {{LayoutConstraints}} object is only passed into the layout function there is no need
    to invalidate the intrinsic sizes.

<div class="note">
    Note: As an example the following properties could change the {{LayoutEdges}} object:
        - 'padding-top'
        - 'border-left-width'
        - 'overflow-y'

    And the following properties could change the {{LayoutConstraints}} object:
        - 'width'
        - 'max-width'
        - 'height'
</div>

Note: This only describes layout invalidation as it relates to the CSS Layout API. All
    <a>boxes</a> conceptually have a <a>layout valid flag</a> and these changes are propagated
    through the <a>box tree</a>.

Layout Worklet {#layout-worklet}
--------------------------------

The {{layoutWorklet}} attribute allows access to the {{Worklet}} responsible for all the classes
which are related to layout.

The {{layoutWorklet}}'s <a>worklet global scope type</a> is {{LayoutWorkletGlobalScope}}.

<pre class='idl'>
partial interface CSS {
    [SameObject] readonly attribute Worklet layoutWorklet;
};
</pre>

The {{LayoutWorkletGlobalScope}} is the global execution context of the {{layoutWorklet}}.

<pre class='idl'>
[Global=(Worklet,LayoutWorklet),Exposed=LayoutWorklet]
interface LayoutWorkletGlobalScope : WorkletGlobalScope {
    void registerLayout(DOMString name, VoidFunction layoutCtor);
};
</pre>

Registering A Layout {#registering-layout}
------------------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
dictionary LayoutOptions {
  ChildDisplayType childDisplay = "block";
  LayoutSizingMode sizing = "block-like";
};

[Exposed=LayoutWorklet]
enum ChildDisplayType {
    "block",
    "normal",
};

[Exposed=LayoutWorklet]
enum LayoutSizingMode {
    "block-like",
    "manual",
};
</pre>

The <a>document</a> has a <a>map</a> of <dfn>document layout definitions</dfn>. Initially this map
is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

The {{LayoutWorkletGlobalScope}} has a <a>map</a> of <dfn>layout definitions</dfn>. Initially this
map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

Each <a>box</a> representing a <a>layout API container</a> has a <a>map</a> of <dfn>layout class
instances</dfn>. Initially this map is empty; it is populated when the user agent calls either
<a>determine the intrinsic sizes</a> or <a>generate a fragment</a> for a <a>box</a>.

<div algorithm>
When the <dfn method for=LayoutWorkletGlobalScope>registerLayout(|name|, |layoutCtor|)</dfn> method
is called, the user agent <em>must</em> run the following steps:
    1. If the |name| is an empty string, <a>throw</a> a <a>TypeError</a> and abort all these steps.

    2. Let |layoutDefinitionMap| be {{LayoutWorkletGlobalScope}}'s <a>layout definitions</a> map.

    3. If |layoutDefinitionMap|[|name|] <a for=map>exists</a> <a>throw</a> a
        "<a>InvalidModificationError</a>" <a>DOMException</a> and abort all these steps.

    4. Let |inputProperties| be an empty <code>sequence&lt;DOMString></code>.

    5. Let |inputPropertiesIterable| be the result of <a>Get</a>(|layoutCtor|, "inputProperties").

    6. If |inputPropertiesIterable| is not undefined, then set |inputProperties| to the result of
        <a>converting</a> |inputPropertiesIterable| to a <code>sequence&lt;DOMString></code>. If an
        exception is <a>thrown</a>, rethrow the exception and abort all these steps.

        Note: The list of CSS properties provided by the input properties getter can either be
            custom or native CSS properties.

        Note: The list of CSS properties may contain shorthands.

        Note: In order for a layout class to be forwards compatible, the list of CSS properties can
            also contains currently invalid properties for the user agent. For example
            <code>margin-bikeshed-property</code>.

    7. Let |childInputProperties| be an empty <code>sequence&lt;DOMString></code>.

    8. Let |childInputPropertiesIterable| be the result of <a>Get</a>(|layoutCtor|,
        "childInputProperties").

    9. If |childInputPropertiesIterable| is not undefined, then set |childInputProperties| to the
        result of <a>converting</a> |childInputPropertiesIterable| to a
        <code>sequence&lt;DOMString></code>. If an exception is <a>thrown</a>, rethrow the exception
        and abort all these steps.

    10. Let |layoutOptionsValue| be the result of <a>Get</a>(|layoutCtor|, "layoutOptions").

    11. Let |layoutOptions| be the result of <a>converting</a> |layoutOptionsValue| to a
        {{LayoutOptions}}. If an exception is <a>thrown</a>, rethrow the exception and abort all
        these steps.

    12. If the result of <a>IsConstructor</a>(|layoutCtor|) is false, <a>throw</a> a
        <a>TypeError</a> and abort all these steps.

    13. Let |prototype| be the result of <a>Get</a>(|layoutCtor|, "prototype").

    14. If the result of <a>Type</a>(|prototype|) is not Object, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    15. Let |intrinsicSizes| be the result of <a>Get</a>(|prototype|,
        <code>"intrinsicSizes"</code>).

    16. If the result of <a>IsCallable</a>(|intrinsicSizes|) is false, <a>throw</a> a
        <a>TypeError</a> and abort all these steps.

    17. If |intrinsicSizes|'s <code>\[[FunctionKind]]</code> internal slot is not
        <code>"generator"</code>, <a>throw</a> a <a>TypeError</a> and abort all these steps.

    18. Let |layout| be the result of <a>Get</a>(|prototype|, <code>"layout"</code>).

    19. If the result of <a>IsCallable</a>(|layout|) is false, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    20. If |layout|'s <code>\[[FunctionKind]]</code> internal slot is not <code>"generator"</code>,
        <a>throw</a> a <a>TypeError</a> and abort all these steps.

    21. Let |definition| be a new <a>layout definition</a> with:

        - <a>class constructor</a> being |layoutCtor|.

        - <a>layout generator function</a> being |layout|.

        - <a>intrinsic sizes generator function</a> being |intrinsicSizes|.

        - <a>constructor valid flag</a> being <b>true</b>.

        - <a for="layout definition">input properties</a> being |inputProperties|.

        - <a for="layout definition">child input properties</a> being |childInputProperties|.

        - <a for="layout definition">layout options</a> being |layoutOptions|.

    22. <a for=map>Set</a> |layoutDefinitionMap|[|name|] to |definition|.

    23. <a>Queue a task</a> to run the following steps:

        1. Let |documentLayoutDefinitionMap| be the associated <a>document's</a> <a>document layout
            definitions</a> <a>map</a>.

        2. Let |documentDefinition| be a new <a>document layout definition</a> with:

            - <a for="document layout definition">input properties</a> being |inputProperties|.

            - <a for="document layout definition">child input properties</a> being
                |childInputProperties|.

            - <a for="document layout definition">layout options</a> being |layoutOptions|.

        3. If |documentLayoutDefinitionMap|[|name|] <a for=map>exists</a>, run the following steps:

            1. Let |existingDocumentDefinition| be the result of <a for=map>get</a>
                |documentLayoutDefinitionMap|[|name|].

            2. If |existingDocumentDefinition| is <code>"invalid"</code>, abort all these steps.

            3. If |existingDocumentDefinition| and |documentDefinition| are not equivalent, (that is
                <a for="document layout definition">input properties</a>, <a for="document layout
                definition">child input properties</a>, and <a for="document layout
                definition">layout options</a> are different), then:

                <a for=map>Set</a> |documentLayoutDefinitionMap|[|name|] to <code>"invalid"</code>.

                Log an error to the debugging console stating that the same class was registered
                with different <code>inputProperties</code>, <code>childInputProperties</code>, or
                <code>layoutOptions</code>.

        4. Otherwise, <a for=map>set</a> |documentLayoutDefinitionMap|[|name|] to
            |documentDefinition|.

<div class='note'>
    Note: The shape of the class should be:
    <pre class='lang-javascript'>
        class MyLayout {
            static get inputProperties() { return ['--foo']; }
            static get childrenInputProperties() { return ['--bar']; }
            static get layoutOptions() {
              return {childDisplay: 'normal', sizing: 'block-like'}
            }

            *intrinsicSizes(children, edges, styleMap) {
                // Intrinsic sizes code goes here.
            }

            *layout(children, edges, constraints, styleMap, breakToken) {
                // Layout code goes here.
            }
        }
    </pre>
</div>
</div>

Layout Engine {#layout-engine}
------------------------------

<div class="issue">
  Issue: Currently the API is in an iterable generator form. Based on implementation experience, and
  web developer experience, this may change to promise based API instead. There are both pros and
  cons to each of these.

  <em>Promises</em>
     - Better error reporting.
     - Potentially better developer ergonomics.

  <em>Generator</em>
     - More "strict" - can only perform layout operations. Don't have to restrict which promise APIs
         work each call.
     - Potentially better bindings overhead.
</div>

### Request Objects ### {#request-objects}

<pre class="idl">
[Exposed=LayoutWorklet]
interface IntrinsicSizesRequest {
};

[Exposed=LayoutWorklet]
interface LayoutFragmentRequest {
};

typedef (IntrinsicSizesRequest or LayoutFragmentRequest)
    LayoutFragmentRequestOrIntrinsicSizesRequest;
</pre>

The {{IntrinsicSizesRequest}} has internal slot(s):
    - <dfn attribute for=IntrinsicSizesRequest>\[[layoutChild]]</dfn> a {{LayoutChild}}, this is the
        child which the intrinsic sizes must be calculated for.

The {{LayoutFragmentRequest}} has internal slot(s):
    - <dfn attribute for=LayoutFragmentRequest>\[[layoutChild]]</dfn> a {{LayoutChild}}, this is the
        child which the fragment must be generated for.
    - <dfn attribute for=LayoutFragmentRequest>\[[layoutConstraints]]</dfn> a
        {{LayoutConstraintsOptions}} dictionary, these are the input constraints to the
        {{LayoutChild}}'s layout algorithm.
    - <dfn attribute for=LayoutFragmentRequest>\[[breakToken]]</dfn> a {{ChildBreakToken}} object,
        which is the break token the layout must be resumed with.

<hr>

The layout method and intrinsic sizes method on the author supplied layout class is a generator
function instead of a regular javascript function. This is for user-agents to be able to support
asynchronous and parallel layout engines.

When an author invokes the {{LayoutChild/layoutNextFragment()}} method on a {{LayoutChild}} the
user-agent doesn't synchronously generate a {{LayoutFragment}} to return to the author's code.
Instead it returns a {{LayoutFragmentRequest}}. This is a completely opaque object to the author but
contains internal slots which encapsulates the {{LayoutChild/layoutNextFragment()}} method call.

When a {{LayoutFragmentRequest}}(s) are yielded from a layout generator object the user-agent's
layout engine may run the algorithm asynchronously with other work, and/or on a different thread of
execution. When {{LayoutFragment}}(s) have been produced by the engine, the user-agent will "tick"
the generator object with the resulting {{LayoutFragment}}(s).

The same applies for the {{LayoutChild/intrinsicSizes()}} method.

<div class="example">
An example layout engine written in javascript is shown below.

<pre class="lang-javascript">
class LayoutEngine {
  // This function takes the root of the box-tree, a LayoutConstraints object, and a
  // BreakToken to (if paginating for printing for example) and generates a
  // LayoutFragment.
  layoutEntry(rootBox, rootPageConstraints, breakToken) {
    return layoutFragment({
      box: rootBox,
      layoutConstraints: rootPageConstraints,
      breakToken: breakToken,
    });
  }

  // This function takes a LayoutFragmentRequest and calls the appropriate
  // layout algorithm to generate the a LayoutFragment.
  layoutFragment(fragmentRequest) {
    const box = fragmentRequest.layoutChild;
    const algorithm = selectLayoutAlgorithmForBox(box);
    const fragmentRequestGenerator = algorithm.layout(
        fragmentRequest.layoutConstraints,
        box.children,
        box.styleMap,
        fragmentRequest.breakToken);

    let nextFragmentRequest = fragmentRequestGenerator.next();

    while (!nextFragmentRequest.done) {
      // A user-agent may decide to perform layout to generate the fragments in
      // parallel on separate threads. This example performs them synchronously
      // in order.
      let fragments = nextFragmentRequest.value.map(layoutFragment);

      // A user-agent may decide to yield for other work (garbage collection for
      // example) before resuming this layout work. This example just performs
      // layout synchronously without any ability to yield.
      nextFragmentRequest = fragmentRequestGenerator.next(fragments);
    }

    return nextFragmentRequest.value; // Return the final LayoutFragment.
  }
}
</pre>
</div>

Performing Layout {#performing-layout}
--------------------------------------

<pre class='idl'>
// This is the final return value from the author defined layout() method.
dictionary FragmentResultOptions {
    double inlineSize = 0;
    double blockSize = 0;
    double autoBlockSize = 0;
    sequence&lt;LayoutFragment> childFragments = [];
    any data = null;
    BreakTokenOptions breakToken = null;
};

dictionary IntrinsicSizesResultOptions {
    double maxContentSize;
    double minContentSize;
};
</pre>

### Determining Intrinsic Sizes ### {#determining-intrinsic-sizes}

The <a>determine the intrinsic sizes</a> algorithm defines how a user agent is to query the author
defined layout for a <a>box's</a> <a>intrinsic sizes</a> information.

Note: The <a>determine the intrinsic sizes</a> algorithm allows for user agents to cache an arbitary
    number of previous invocations to reuse.

<div algorithm="determine the intrinsic sizes">
When the user agent wants to <dfn>determine the intrinsic sizes</dfn> of a <a>layout API formatting
context</a> for a given |box|, |childBoxes| it <em>must</em> run the following steps:

    1. Let |layoutFunction| be the ''layout()'' for the <a>computed value</a> of <<display-inside>>
        for |box|.

    2. If the <a>intrinsic sizes valid flag</a> for the |layoutFunction| is
        <a>intrinsic-sizes-valid</a> the user agent <em>may</em> use the intrinsic sizes from the
        previous invocation. If so it <em>may</em> abort all these steps and use the previous value
        for the intrinsic sizes.

    3. Set the <a>intrinsic sizes valid flag</a> for the |layoutFunction| to
        <a>intrinsic-sizes-valid</a>.

    4. Let |name| be the first argument of the |layoutFunction|.

    5. Let |documentDefinition| be the result of <a>get a document layout definition</a> given
        |name|.

        If <a>get a document layout definition</a> returned failure, or if |documentDefinition| is
        <code>"invalid"</code>, then let |box| fallback to the <a>flow layout</a> and abort all
        these steps.

    6. Let |workletGlobalScope| be a {{LayoutWorkletGlobalScope}} from the list of <a>worklet's
        WorkletGlobalScopes</a> from the layout {{Worklet}}.

        The user agent <em>must</em> have, and select from at least two
        {{LayoutWorkletGlobalScope}}s in the <a>worklet's WorkletGlobalScopes</a> <a>list</a>,
        unless the user agent is under memory constraints.

        Note: This is to ensure that authers do not rely on being able to store state on the global
            object or non-regeneratable state on the class.

        The user agent <em>may</em> also <a>create a WorkletGlobalScope</a> at this time, given the
        layout {{Worklet}}.

    7. Run <a>invoke a intrinsic sizes callback</a> given |name|, |box|, |childBoxes|, and
        |workletGlobalScope| optionally <a>in parallel</a>.

        Note: If the user agent runs <a>invoke a intrinsic sizes callback</a> on a thread <a>in
            parallel</a>, it should select a layout worklet global scope which can be used on that
            thread.
</div>

<div algorithm="invoke a intrinsic sizes callback">
When the user agent wants to <dfn>invoke a intrinsic sizes callback</dfn> given |name|, |box|,
|childBoxes|, and |workletGlobalScope|, it <em>must</em> run the following steps:

    1. Let |definition| be the result of <a>get a layout definition</a> given |name|, and
        |workletGlobalScope|.

        If <a>get a layout definition</a> returned failure, let the |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    2. Let |layoutInstance| be the result of <a>get a layout class instance</a> given |box|,
        |definition|, |workletGlobalScope|.

        If <a>get a layout class instance</a> returned failure, let the |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    3. Let |inputProperties| be |definition|'s <a for="layout definition">input properties</a>.

    4. Let |children| be a new <a>list</a>.

    5. <a for=list>For each</a> |childBox| in |childBoxes| perform the following substeps:

        1. Let |layoutChild| be the result of <a>get a layout child</a> given |workletGlobalScope|,
            |name|, and |childBox|.

        2. <a for=list>Append</a> |layoutChild| to |children|.

    6. Let |edges| be a new {{LayoutEdgeSizes}} populated with the <a>computed value</a> for all the
        <a>box model edges</a> for |box|.

    7. Let |styleMap| be a new {{StylePropertyMapReadOnly}} populated with <em>only</em> the
        <a>computed values</a> for properties listed in |inputProperties| for |box|.

        Issue: We may want to store |styleMap| on |box| instead, similar to |layoutInstance|.

    8. At this stage the user agent may re-use the <a>intrinsic sizes</a> from a previous invocation
        if |children|, |styleMap| are equivalent to that previous invocation. If so let the
        intrinsic sizes the cached intrinsic sizes and abort all these steps.

    9. Let |intrinsicSizesGeneratorFunction| be |definition|'s <a>intrinsic sizes generator
        function</a>.

    10. Let |intrinsicSizesGenerator| be the result of
        <a>Invoke</a>(|intrinsicSizesGeneratorFunction|, |layoutInstance|, |children|, |edges|,
        |styleMap|).

        If an exception is <a>thrown</a> the let |box| fallback to the <a>flow layout</a> and abort
        all these steps.

    11. Let |intrinsicSizesValue| be the result of <a>run a generator</a> given
        |intrinsicSizesGenerator|, and <code>"intrinsic-sizes"</code>.

        If <a>run a generator</a> returned failure, then let |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    12. Let |intrinsicSizes| be the result of <a>converting</a> |intrinsicSizesValue| to a
        {{IntrinsicSizesResultOptions}}. If an exception is <a>thrown</a>, let |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    13. Set the <a>intrinsic sizes</a> of |box|:

        - Let |intrinsicSizes|'s {{IntrinsicSizesResultOptions/minContentSize}} be the
            <a>min-content size</a> of |box|.

        - Let |intrinsicSizes|'s {{IntrinsicSizesResultOptions/maxContentSize}} be the
            <a>max-content size</a> of |box|.
</div>

### Generating Fragments ### {#generating-fragments}

The <a>generate a fragment</a> algorithm defines how a user agent is to generate a <a>box's</a>
<a>fragment</a> for an author defined layout.

Note: The <a>generate a fragment</a> algorithm allows for user agents to cache an arbitary number of
    previous invocations to reuse.

<div algorithm="generate a fragment">
When the user agent wants to <dfn>generate a fragment</dfn> of a <a>layout API formatting
context</a> for a given |box|, |childBoxes|, |internalLayoutConstraints|, and an optional
|internalBreakToken| it <em>must</em> run the following steps:

    1. Let |layoutFunction| be the ''layout()'' for the <a>computed value</a> of <<display-inside>>
        for |box|.

    2. If the <a>layout valid flag</a> for the |layoutFunction| is <a>layout-valid</a> the user
        agent <em>may</em> use the intrinsic sizes from the previous invocation. If so it
        <em>may</em> abort all these steps and use the previous value for the intrinsic sizes.

    3. Set the <a>layout valid flag</a> for the |layoutFunction| to <a>layout-valid</a>.

    4. Let |name| be the first argument of the |layoutFunction|.

    5. Let |documentDefinition| be the result of <a>get a document layout definition</a> given
        |name|.

        If <a>get a document layout definition</a> returned failure, or if |documentDefinition| is
        <code>"invalid"</code>, then let |box| fallback to the <a>flow layout</a> and abort all
        these steps.

    6. Let |workletGlobalScope| be a {{LayoutWorkletGlobalScope}} from the list of <a>worklet's
        WorkletGlobalScopes</a> from the layout {{Worklet}}.

        The user agent <em>must</em> have, and select from at least two
        {{LayoutWorkletGlobalScope}}s in the <a>worklet's WorkletGlobalScopes</a> <a>list</a>,
        unless the user agent is under memory constraints.

        Note: This is to ensure that authers do not rely on being able to store state on the global
            object or non-regeneratable state on the class.

        The user agent <em>may</em> also <a>create a WorkletGlobalScope</a> at this time, given the
        layout {{Worklet}}.

    7. Run <a>invoke a layout callback</a> given |name|, |box|, |childBoxes|,
        |internalLayoutConstraints|, |internalBreakToken|, and |workletGlobalScope| optionally <a>in
        parallel</a>.

        Note: If the user agent runs <a>invoke a intrinsic sizes callback</a> on a thread <a>in
            parallel</a>, it should select a layout worklet global scope which can be used on that
            thread.
</div>

<div algorithm="invoke a layout callback">
When the user agent wants to <dfn>invoke a layout callback</dfn> given |name|, |box|, |childBoxes|,
|internalLayoutConstraints|, |internalBreakToken|, and |workletGlobalScope|, it <em>must</em> run the
following steps:

    1. Let |definition| be the result of <a>get a layout definition</a> given |name|, and
        |workletGlobalScope|.

        If <a>get a layout definition</a> returned failure, let the |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    2. Let |layoutInstance| be the result of <a>get a layout class instance</a> given |box|,
        |definition|, |workletGlobalScope|.

        If <a>get a layout class instance</a> returned failure, let the |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    3. Let |sizingMode| be |definition|'s <a for="layout definition">layout options</a>'
        {{LayoutOptions/sizing}} property.

    4. Let |inputProperties| be |definition|'s <a for="layout definition">input properties</a>.

    5. Let |children| be a new <a>list</a>.

    6. <a for=list>For each</a> |childBox| in |childBoxes| perform the following substeps:

        1. Let |layoutChild| be the result of <a>get a layout child</a> given |workletGlobalScope|,
            |name|, and |childBox|.

        2. <a for=list>Append</a> |layoutChild| to |children|.

    7. Let |edges| be a new {{LayoutEdgeSizes}} populated with the <a>computed value</a> for all the
        <a>box model edges</a> for |box|.

    8. Let |layoutConstraints| be the result of <a>create a layout constraints object</a> given
        |internalLayoutConstraints|, |box|, and |sizingMode|.

    9. Let |styleMap| be a new {{StylePropertyMapReadOnly}} populated with <em>only</em> the
        <a>computed values</a> for properties listed in |inputProperties| for |box|.

        Issue: We may want to store |styleMap| on |box| instead, similar to |layoutInstance|.

    10. Let |breakToken| be a new {{BreakToken}} populated with the appropriate information from
        |internalBreakToken|.

        If |internalBreakToken| is null, let |breakToken| be null.

    11. At this stage the user agent may re-use a <a>fragment</a> from a previous invocation if
        |children|, |styleMap|, |layoutConstraints|, |breakToken| are equivalent to that previous
        invocation. If so let the fragment output be that cached fragment and abort all these steps.

    12. Let |layoutGeneratorFunction| be |definition|'s <a>layout generator function</a>.

    13. Let |layoutGenerator| be the result of <a>Invoke</a>(|layoutGeneratorFunction|,
        |layoutInstance|, |children|, |edges|, |layoutConstraints|, |styleMap|, |breakToken|).

        If an exception is <a>thrown</a> the let |box| fallback to the <a>flow layout</a> and abort
        all these steps.

    14. Let |fragmentValue| be the result of <a>run a generator</a> given |layoutGenerator|, and
        <code>"layout"</code>.

        If <a>run a generator</a> returned failure, then let |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    15. Let |fragment| be the result of <a>converting</a> |fragmentValue| to a
        {{FragmentResultOptions}}. If an exception is <a>thrown</a>, let |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    16. <a for=list>For each</a> |childFragment| in |fragment|'s
        {{FragmentResultOptions/childFragments}}, perform the following stubsteps:

        1. If |childFragment|'s {{[[generator]]}} internal slot is not equal to |layoutGenerator|,
            then let |box| fallback to the <a>flow layout</a> and abort all these steps.

    17. If |sizingMode| is <code>"block-like"</code>:

        - Then:

            1. Let |inlineSize| be |layoutConstraints|' {{LayoutConstraints/fixedInlineSize}}. (This
                value must be set if we are using <code>"block-like"</code> sizing).

            2. Let |blockSize| be the result of calculating |box|'s <b>border-box</b>
                <a>block size</a> (relative to |box|'s writing mode) exactly like block containers
                do, given |fragment|'s {{FragmentResultOptions/autoBlockSize}} as the "intrinsic
                height".

        - Otherwise (|sizingMode| is <code>"manual"</code>):

            1. Let |inlineSize| be |fragment|'s {{FragmentResultOptions/inlineSize}}.

            2. Let |blockSize| be |fragment|'s {{FragmentResultOptions/blockSize}}.

    18. Return a <a>fragment</a> for |box| with:

        - The <a>inline size</a> set to |inlineSize|.

        - The <a>block size</a> set to |blockSize|.

        - The child fragments set to |fragment|'s {{FragmentResultOptions/childFragments}}
            <a>list</a>. The ordering <em>is</em> important as this dictates their paint order
            (described in [[#layout-api-containers]]). Their position relative to the <b>border
            box</b> of the |fragment| should be based off the author specified
            {{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}}.

        - The <a>fragmentation break</a> information set to |fragment|'s
            {{FragmentResultOptions/breakToken}}.

        - Let |clonedData| be the result of invoking <a>StructuredSerializeForStorage</a> on
            |fragment|'s {{FragmentResultOptions/data}}.

            The user agent must store |clonedData| with the <a>fragment</a>.
</div>

### Utility Algorithms ### {#utility-algorithms}

The section specifies algorithms common to the <a>determine the intrinsic sizes</a> and <a>generate
a fragment</a> algorithms.

<div algorithm="get a document layout definition">
When the user agent wants to <dfn>get a document layout definition</dfn> given |name|, it
<em>must</em> run the following steps:

    1. Let |documentLayoutDefinitionMap| be the associated <a>document's</a> <a>document layout
        definitions</a> map.

    2. If |documentLayoutDefinitionMap|[|name|] does not <a for=map>exist</a>, return failure and
        abort all these steps.

    3. Return the result of <a for=map>get</a> |documentLayoutDefinitionMap|[|name|].
</div>

<div algorithm="get a layout definition">
When the user agent wants to <dfn>get a layout definition</dfn> given |name|, and
|workletGlobalScope|, it <em>must</em> run the following steps:

    1. Let |layoutDefinitionMap| be |workletGlobalScope|'s <a>layout definitions</a> map.

    2. If |layoutDefinitionMap|[|name|] does not <a for=map>exist</a>, run the following steps:

        1. <a>Queue a task</a> to run the following steps:

            1. Let |documentLayoutDefinitionMap| be the associated <a>document's</a> <a>document
                layout definition</a> map.

            2. <a for=map>Set</a> |documentLayoutDefinitionMap|[|name|] to <code>"invalid"</code>.

            3. The user agent <em>should</em> log an error to the debugging console stating that a
                class wasn't registered in all {{LayoutWorkletGlobalScope}}s.

        2. Return failure, and abort all these steps.

    3. Return the result of <a>get</a> |layoutDefinitionMap|[|name|].
</div>

<div algorithm="get a layout class instance">
When the user agent wants to <dfn>get a layout class instance</dfn> given |box|, |definition|, and
|workletGlobalScope|, it <em>must</em> run the following steps:

    1. Let |layoutClassInstanceMap| be |box|'s <a>layout class instances</a> map.

    2. Let |layoutInstance| be the result of <a>get</a>
        |layoutClassInstanceMap|[|workletGlobalScope|]. If |layoutInstance| is null, run the
        following steps:

        1. If the <a>constructor valid flag</a> on |definition| is false, then return failure and
            abort all these steps.

        2. Let |layoutCtor| be the <a>class constructor</a> on |definition|.

        3. Let |layoutInstance| be the result of <a>Construct</a>(|layoutCtor|).

            If <a>construct</a> throws an exception, set the |definition|'s <a>constructor valid
            flag</a> to false, then return failure and abort all these steps.

        4. <a for=map>Set</a> |layoutClassInstanceMap|[|workletGlobalScope|] to |layoutInstance|.

    4. Return |layoutInstance|.
</div>

<div algorithm="run a generator">
When the user agent wants to <dfn>run a generator</dfn> given |generator|, and |generatorType|, it
<em>must</em> run the following steps:

    1. Let |done| be a <a>boolean</a> initialized to <code>false</code>.

    2. Let |nextValue| be undefined.

    3. Perform the following substeps until |done| is <code>true</code>:

        1. Let |nextFunction| be the result of <a>Get</a>(|generator|, <code>"next"</code>).

        2. If the result of <a>IsCallable</a>(|nextFunction|) is false, <a>throw</a> a
            <a>TypeError</a> and abort all these steps.

        3. Let |nextResult| be the result of calling <a>Invoke</a>(|nextFunction|, |generator|,
            |nextValue|).

            If an exception is <a>thrown</a> return failure, and abort all these steps.

        4. If the result of <a>Type</a>(|nextResult|) is not Object, <a>throw</a> a <a>TypeError</a>
            and abort all these steps.

        5. Let |requestOrRequests| be the result of <a>Get</a>(nextResult|, <code>"value"</code>).

        6. Let |done| be the result of <a>Get</a>(|nextResult|, <code>"done"</code>).

        7. If the result of <a>GetMethod</a>(|requestOrRequests|, <code>@@iterable</code>) exists
            then:

            1. Set |results| to be a new <a for=list>empty</a> <a>list</a>.

            2. Let |requests| be the result of <a>converting</a> |requestOrRequests| to a
                <code>sequence&lt;LayoutFragmentRequestOrIntrinsicSizesRequest></code>.

                If an exception is <a>thrown</a>, rethrow the exception and abort all these steps.

            3. <a for=list>For each</a> |request| in |requests| perform the following substeps:

                1. Let |result| be the result of <a>produce a generator result</a> given |request|,
                      |generator|, |generatorType|.

                2. <a for=list>Append</a> |result| to |results|.

            4. Set |nextValue| to be |results|.

            5. Continue.

        8. Let |request| be the result of <a>converting</a> |requestOrRequests| to a
            {{LayoutFragmentRequestOrIntrinsicSizesRequest}}.

            If an exception is <a>thrown</a>, rethrow the exception and abort all these steps.

        9. Let |result| be the result of <a>produce a generator result</a> given |request|,
            |generator|, |generatorType|.

            If <a>produce a generator result</a> returns failure, return failure, and abort all
            these steps.

        10. Set |nextValue| to be |result|.

        11. Continue.

        The user agent may perform the above loop out of order, and <a>in parallel</a>. The ordering
        for |requests| and |results| however <em>must</em> be consistent.

        Note: This is to allow user agents to run the appropriate layout algorithm on a different
            thread, or asynchronously (e.g. time slicing layout work with other work). If the user
            agent performs the loop in parallel, the outside loop has to wait until all the cross
            thread tasks are complete before calling the generator again. It cannot return partial
            results to the author.

    3. Return the result of calling <a>Get</a>(|nextResult|, <code>"value"</code>).
</div>

<div algorithm="produce a generator result">
When the user agent wants to <dfn>produce a generator result</dfn> given |request|, |generator|, and
|generatorType|, it <em>must</em> run the following steps:
    1. If |request| is a {{IntrinsicSizesRequest}} then:

        1. Let |layoutChild| be the result of looking up the internal slot
            {{IntrinsicSizesRequest/[[layoutChild]]}} on |request|.

        2. Let |box| be the result of looking up the internal slot {{LayoutChild/[[box]]}} on
            |layoutChild|.

        3. If |box| is <em>not</em> attached to the <a>box tree</a>, return failure and abort all
            these steps.

            Note: The author may hold onto a {{LayoutChild}} from a previous invocation. It is
                assumed that a box is only ever attached to the box-tree once, and not re-used.

        4. Let |internalIntrinsicSizes| be the result of the user agent calculating the <b>border
            box</b> min/max content contribution of |box|.

        5. Return the result of <a>create an intrinsic sizes object</a> given |request|, and
            |internalIntrinsicSizes|.

    2. If |request| is a {{LayoutFragmentRequest}} and |generatorType| is <code>"layout"</code>
        then:

        1. Let |layoutChild| be result of looking up the internal slot
            {{LayoutFragmentRequest/[[layoutChild]]}} on |request|.

        2. Let |box| be the result of looking up the internal slot {{LayoutChild/[[box]]}} on
            |layoutChild|.

        3. If |box| is <em>not</em> attached to the <a>box tree</a>, return failure and abort all
            these steps.

            Note: The author may hold onto a {{LayoutChild}} from a previous invocation. It is
                assumed that a box is only ever attached to the box-tree once, and not re-used.

        4. Let |childLayoutConstraints| be the result of looking up the internal slot
            {{LayoutFragmentRequest/[[layoutConstraints]]}} on |request|.

        5. Let |childBreakToken| be the result of looking up the internal slot
            {{LayoutFragmentRequest/[[breakToken]]}} on |request|.

        6. Let |internalFragment| be the result of the user agent producing a <a>fragment</a> based
            on |box|, |childLayoutConstraints|, and |childBreakToken|.

        7. Return the result of <a>create a layout fragment</a> given |generator|, |request|, and
            |internalFragment|.

    3. Return failure (neither of the above branches was taken).
</div>

Security Considerations {#security-considerations}
==================================================

There are no known security issues introduced by these features.

Privacy Considerations {#privacy-considerations}
================================================

There are no known privacy issues introduced by these features.
