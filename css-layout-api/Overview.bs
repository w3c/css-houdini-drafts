<pre class='metadata'>
Title:  CSS Layout API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-layout-api-1/
Shortname: css-layout-api
Level: 1
Abstract:
Editor: Greg Whitworth, gwhit@microsoft.com 
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Tab Atkins, jackalmage@gmail.com
Editor: Shane Stephens, shanestephens@google.com
Editor: Robert O'Callahan, robert@ocallahan.org
Editor: Rossen Atanassov, rossen.atanassov@microsoft.com
</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
</pre>

Introduction {#intro}
=====================

The layout stage of CSS is responsible for generating and positioning <a>fragments</a> from a tree
of <a>boxes</a>.

This specification describes an API which allows developers to layout a <a>box</a> in response to
computed style and <a>box</a> tree changes.

Layout Model and Terminology {#layout-model-and-terminology}
============================================================

The <dfn>current layout</dfn> is the layout algorithm for the {{Box}} we are currently performing
layout for.

The <dfn>parent layout</dfn> is the layout algorithm for the {{Box}}'s direct parent, (the layout
algorithm which is requesting the <a>current layout</a> to be performed).

A <dfn>child layout</dfn> is the layout algorithm for a child of the {{Box}}.

Layout Boxes {#layout-boxes}
----------------------------

<pre class='idl'>
interface Box {
    readonly attribute ComputedStylePropertyMapReadOnly styleMap;
    FragmentRequestToken doLayout(ConstraintSpace space, OpaqueBreakToken breakToken);
};
</pre>

Issue(w3c/css-houdini-drafts#254): We may want a different name for the {{Box}} concept. In this
    context box has no layout information only style.

A {{Box}} represents a CSS generated <a>box</a> before any layout has occurred. (The box will have a
computed value of 'display' that is not ''none''). The {{Box}} does not contain any layout
information itself (like inline or block size) but can be used to generate {{Fragment}}s which do
contain layout information.

A box could be generated by:

 - An <a>element</a>.

 - A <a>::before</a> or <a>::after</a> pseudo-element.

    NOTE: Other pseudo-elements such as <a>::first-letter</a> or <a>::first-line</a> do not generate
        a box for layout purposes. They are additional styling information for a text node.

 - A <a>Text</a> node.

 - An anonymous box inserted as a result of:

    - A <a>Text</a> node which has undergone <a>blockification</a>.

    - An element with ''display: table-cell'' which doesn't have a parent with ''display: table''.

    Issue(w3c/css-houdini-drafts#255): Specify which scenarios actually generate a {{Box}} for
        layout purposes.

An array of {{Box}}es is passed into the <a>layout method</a> which represents the child boxes of
the current box which is being laid out.

The author can query the <a>computed style</a> of the child box through the {{Box/styleMap}}
attribute. The {{Box/styleMap}} will only contain properties which are listed in the <a>child input
properties</a> array.

To perform layout on a box the author can invoke the <<Box/doLayout()>> method. This will produce a
{{Fragment}} which contains layout information.

The <<Box/doLayout()>> method may be invoked multiple times with different arguments to query the
{{Box}} for different layout information.

Layout Fragments {#layout-fragments}
------------------------------------

<pre class='idl'>
interface Fragment {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    attribute double inlineOffset;
    attribute double blockOffset;

    readonly attribute sequence&lt;Box> unpositionedBoxes;

    readonly attribute OpaqueBreakToken? breakToken;

    readonly attribute double dominantBaseline;
    readonly attribute double alphabeticBaseline;
    readonly attribute double textTopBaseline;
    readonly attribute double textBottomBaseline;
    readonly attribute double textCenterBaseline;

    readonly attribute Object data;
};
</pre>

A {{Fragment}} represents a CSS <a>fragment</a> of a <a>box</a> after layout has occurred on that
box. This is produced by the <<Box/doLayout()>> method.

The {{Fragment}} has {{Fragment/inlineSize}} and {{Fragment/blockSize}} attributes, which are set by
the respective {{Box}}'s layout algorithm. They cannot be changed. If the <a>current layout</a>
requires a different {{Fragment/inlineSize}} or {{Fragment/blockSize}} the author must perform
{{doLayout()}} again with different arguments in order to get different results.

The {{Fragment}} has a list of {{Fragment/unpositionedBoxes}}. These are boxes which the child
layout algorithm could not position itself, and should be positioned by either the <a>current
layout</a>, or a <a>parent layout</a>.

NOTE: As an example, if a <a>child layout</a> is not a <a>containing block</a> its resulting
    {{Fragment}} will contain a list of the positioned boxes (e.g. an element that has ''positioned:
    absolute'') it cannot layout. If the <a>current layout</a> is a <a>containing block</a> it
    should layout and position those boxes, or if not pass them up to it's <a>parent layout</a>.

The author inside the current layout can position a resulting {{Fragment}} by setting its
{{Fragment/inlineOffset}} and {{Fragment/blockOffset}} attributes. If not set by the author they
default to zero.

<div class="example">
The following code assumes that each child {{Box}} is a <a>containing block</a> and produces exactly
one {{Fragment}} for simplicity.

The layout algorithm performs a block-like layout (laying things out in the block direction), while
centering its children in the inline direction.

<pre class="lang-javascript">
registerLayout('block-like', class {
    *layout(space, children, styleMap, breakToken) {
        let blockOffset = 0;
        const inlineSize = resolveInlineSize(space, styleMap);
        const childFragments = [];

        // ... snip ...

        for (let child of children) {
            let fragment = yield child.doLayout(childSpace);

            // Position the fragment in a block like manner, centering it in the
            // inline direction.
            fragment.blockOffset = blockOffset;
            fragment.inlineOffset =
                Math.max(0, (inlineSize - fragment.inlineSize) / 2);

            blockOffset += fragment.blockSize;
        }

        // ... snip ...

        return {
            blockSize: blockOffset,
            inlineSize: inlineSize,
            fragments: childFragments,
        };
    }
});
</pre>
</div>

The {{Fragment}}'s {{Fragment/breakToken}} specifies where the {{Box}} last fragmented. If the
{{Fragment/breakToken}} is null the {{Box}} cannot produce any more {{Fragment}}s. The
{{Fragment/breakToken}} can be passed to the <<doLayout()>> function to produce the next
{{Fragment}} for a particular {{Box}}. The {{Fragment/breakToken}} cannot be changed. If the
<a>current layout</a> requires a different {{Fragment/breakToken}} the author must perform
<<doLayout()>> again with different arguments.

The {{Fragment}}'s {{Fragment/dominantBaseline}}, {{Fragment/alphabeticBaseline}},
{{textTopBaseline}}, {{textCenterBaseline}}, and {{Fragment/textBottomBaseline}} attributes specify
where all the baselines for the {{Fragment}} are positioned. They cannot be changed.

Constraint Spaces {#constraint-spaces}
--------------------------------------

<pre class='idl'>
[Constructor(optional ConstraintSpaceOptions), Constructor(ConstraintSpace)]
interface ConstraintSpace {
    readonly attribute double? inlineSize;
    readonly attribute double? blockSize;

    readonly attribute boolean fixedInlineSize;
    readonly attribute boolean fixedBlockSize;

    readonly attribute double inlinePercentResolutionSize;
    readonly attribute double blockPercentResolutionSize;

    readonly attribute double? inlineScrollTriggerOffset;
    readonly attribute double? blockScrollTriggerOffset;

    readonly attribute double? blockFragmentationOffset;
};

dictionary ConstraintSpaceOptions {
    double? inlineSize = null;
    double? blockSize = null;

    boolean fixedInlineSize = false;
    boolean fixedBlockSize = false;

    double inlinePercentResolutionSize = null;
    double blockPercentResolutionSize = null;

    double inlineScrollTriggerOffset = null;
    double blockScrollTriggerOffset = null;

    double blockFragmentationOffset = null;
};
</pre>

A {{ConstraintSpace}} is passed into the <a>layout method</a> which represents the available space
for the <a>current layout</a> to perform layout inside. It is also used to pass information about
the available space into a <a>child layout</a>.

The {{ConstraintSpace}} has {{ConstraintSpace/inlineSize}} and {{ConstraintSpace/blockSize}}
attributes. This represent the maximum size of a {{Fragment}} which the <a>current layout</a> should
produce.

NOTE: Some layouts may need to produce a {{Fragment}} which exceed this size. For example a
    <a>replaced element</a>. The <a>current layout</a> should expect this to occur and deal with it
    appropriately.

If either the {{ConstraintSpace/inlineSize}} or {{ConstraintSpace/blockSize}} attributes are null
the <a>current layout</a> can assume it has infinite space to perform layout in that direction.

NOTE: As an example a <a>current layout</a> could query for the <a>max content contribution</a> of a
    {{Box}} by giving it a {{ConstraintSpace}} which has a infinite {{ConstraintSpace/inlineSize}}
    and {{ConstraintSpace/blockSize}}.

A <a>parent layout</a> may require the <a>current layout</a> to be exactly a particular size. If
the {{ConstraintSpace/fixedInlineSize}} or {{ConstraintSpace/fixedBlockSize}} are true the
<a>current layout</a> should produce a {{Fragment}} with a fixed size in the appropriate direction.

<div class="example">
The following code assumes that each child {{Box}} is a <a>containing block</a>, each child can be
"flexed", and produces exactly one {{Fragment}} for simplicity.

The layout algorithm performs a flexbox-like distribution of spare space in the inline direction. It
creates child constraint spaces which specify that a child should be a fixed inline size.

<pre class="lang-javascript">
registerLayout('flex-distribution-like', class {
    *layout(space, children, styleMap, breakToken) {
        const inlineSize = resolveInlineSize(space, styleMap);

        // Calculate the unconstrained size for each child.
        for (let child of children) {
            let fragment = yield child.doLayout(space);
            unconstrainedSizes.push(fragment.inlineSize);
            totalSize += fragment.inlineSize;
        }

        // Distribute space spare between children.
        const remainingSpace = Math.max(0, inlineSize - totalSize);
        const extraSpace = remainingSpace / children.length;
        const fragments = [];
        let inlineOffset = 0;
        for (let i = 0; i < children.length; i++) {
            let fragment = yield child.doLayout(new ConstraintSpace({
                inlineSize: unconstrainedSizes[i] + extraSpace,
                fixedInlineSize: true,
                blockSize: space.blockSize
            }));

            fragment.inlineOffset = inlineOffset;
            inlineOffset += fragment.inlineSize;

            fragments.push(fragment);
        }

        return {
            fragments: fragments,
            inlineSize: inlineSize,
            /* etc. */
        };
    }
});
</pre>
</div>

The {{ConstraintSpace}} has {{ConstraintSpace/inlinePercentResolutionSize}} and
{{ConstraintSpace/blockPercentResolutionSize}} attributes. These represent the size that a layout
percentages should be resolved against while performing layout.

The {{ConstraintSpace}} has {{ConstraintSpace/inlineScrollTriggerOffset}} and
{{ConstraintSpace/blockScrollTriggerOffset}} attributes. The <a>current layout</a> can use this
information to early opt-out of a layout if it knows it will require additional space for a scroll
bar in that direction. If either the {{ConstraintSpace/inlineScrollTriggerOffset}} or
{{ConstraintSpace/blockScrollTriggerOffset}} attributes are null the <a>current layout</a> can
assume it does not need to report to the parent layout that it will require a scroll bar in that
direction.

The scroll trigger offset should only be present when the <a>parent layout</a> will need to reserve
additional space for the scroll bar. If an overlay scroll bar displayed by the user-agent, the
scroll trigger offset should not be present (as no additional space needs to be reserved for the
overlay scroll bar).

The author may ignore this information and produce a fragment with a
{{LayoutResult/inlineOverflowSize}} or {{LayoutResult/blockOverflowSize}} which exceeds the scroll
trigger offset. In this case the engine invoke the layout algorithm again with space reserved for
the scroll bar if required.

NOTE: The user-agent should provide tooling to the author if this case is triggered, advising that
    the author may be able to optimize their layout with an early opt-out.

<div class="example">
The following code assumes that each child {{Box}} is a <a>containing block</a>, and produces
exactly one {{Fragment}} for simplicity.

The layout algorithm performs a block-like with an early opt-out if it will trigger a scroll.

<pre class="lang-javascript">
registerLayout('block-like-with-scroll', class {
    *layout(space, children, styleMap, breakToken) {
        let blockOffset = 0;
        const inlineSize = resolveInlineSize(space, styleMap);
        const childFragments = [];

        // ... snip ...

        for (let child of children) {
            let fragment = yield child.doLayout(childSpace);

            fragment.blockOffset = blockOffset;
            blockOffset += fragment.blockSize;

            // Early opt-out of layout algorithm if we triggered a scroll in the
            // block direction.
            if (space.blockScrollTriggerOffset != null &&
                space.blockScrollTriggerOffset < blockOffset) {
                return {blockScrollTriggered: true};
            }
        }

        // ... snip ...

        return {
            blockSize: resolveBlockSize(space, styleMap, blockOffset),
            inlineSize: inlineSize,
            blockOverflowSize: blockOffset,
            fragments: childFragments,
        };
    }
});
</pre>
</div>

The {{ConstraintSpace}} has a {{ConstraintSpace/blockFragmentationOffset}} attribute. 

### Constraint Space Exclusions ###

TODO write about exclusions

### Derived Constraint Spaces ###

TODO write about "layout opportunities"

Breaking and Fragmentation {#breaking-and-fragmentation}
--------------------------------------------------------

TODO write about break tokens and fragmentation

Layout Invalidation {#layout-invalidation}
==========================================

<div class='issue'>
TODO, list all the ways that layout can be invalidated, namely:
    - Computed style change.
    - Child computed style change.
    - Child add/remove change.
    - etc.
</div>

Registering A Layout {#registering-a-layout}
============================================

<pre class='idl'>
callback VoidFunction = void ();

partial interface RenderWorkletGlobalScope {
    void registerLayout(DOMString name, VoidFunction layoutCtor);
};
</pre>

The {{RenderWorkletGlobalScope}} has a map of <b>name to layout constructor map</b>. Initially this
map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

Issue: Write full register algorithm, and checks required.

<div class='note'>
    This is what the shape of the class should be:
    <pre class='idl'>
        callback interface LayoutClass {
            readonly attribute sequence&lt;DOMString> inputProperties;
            readonly attribute sequence&lt;DOMString> childInputProperties;

            LayoutResult layout(
                    ConstraintSpace space,
                    sequence&lt;Box> children,
                    StylePropertyMap styleMap,
                    BreakToken break);
            void childrenChange(/*
                    added children,
                    removed children,
                    idx updated children,
                    similar to Array.observe */);
        };
    </pre>
</div>

Layout Notation {#layout-notation}
==================================

<pre class='prod'>
    <dfn>layout()</dfn> = layout( <<ident>> )
    <dfn>inline-layout()</dfn> = inline-layout( <<ident>> )
</pre>

The <<layout()>> and <<inline-layout()>> function is an additional notation to be supported by the ''display'' property.

Issue: Resolve this with css-display-3 once required.

Layout {#layout}
================

Performing layout {#performing-layout}
--------------------------------------

<pre class='idl'>
dictionary LayoutResult {
    double minContent;
    double maxContent;
    double width;
    double height;
    sequence&lt;Fragment> fragments;
    sequence&lt;Fragment> unpositionedFragments;
    BreakToken breakToken;
    double baseline;
};
</pre>

{{LayoutClass/layout()}} is invoked by the user agent when <a>generate a layout</a> for a <a>box</a>.

The user agent passes in:
  - The current children for the <a>box</a>, with only {{LayoutClass/childInputProperties}} on
    {{Box/styleMap}}
  - The available space defined by a {{ConstraintSpace}}
  - The computed style of the <a>box</a>, with only {{LayoutClass/inputProperties}}
  - The {{BreakToken}} if any, for where the <a>box</a> was last fragmented.

The author defined code should produce a {{LayoutResult}}.

The {{LayoutResult}} consists of:
 - A {{LayoutResult/minContent}} which represents the fragment's <a>min-content inline-size
    contribution</a>.
 - A {{LayoutResult/maxContent}} which represents the fragment's <a>max-content inline-size
    contribution</a>.
 - A {{LayoutResult/width}} which represents the fragment's resulting width.
 - A {{LayoutResult/height}} which represents the fragment's resulting height.
 - A list of {{LayoutResult/fragments}} which represents the fragment's direct child fragments.
 - A list of {{LayoutResult/unpositionedFragments}} which represents the fragment's children which
    should be positioned by a parent fragment.
 - A {{LayoutResult/breakToken}} which represents where the current layout's box last broke.
 - A {{LayoutResult/baseline}} which represents the baseline of the fragment.

Issue: Write the following into the algorithm.

If any {{Fragment}}s appear in both the list of {{LayoutResult/fragments}} or the list of
{{LayoutResult/unpositionedFragments}} the user agent should throw an error.

The user agent should check that a consistent set of {{Fragment}}s generated from a {{Box}} is
returned in either the list of {{LayoutResult/fragments}} or {{LayoutResult/unpositionedFragments}}.
(Consistent being that a {{Fragment/breakToken}} from one {{Fragment}} was used to generate another
{{Fragment}} in the set).

If any {{Fragment}}s appear more than once, the user agent should throw an error.

When the user agent wants to <dfn>generate a layout</dfn> of a <<layout()>> or <<inline-layout()>>
for a box it <em>must</em> run the following steps:

Issue: TODO specify these steps.

Examples {#examples}
====================

Example 1: A simple block layout {#example-1}
---------------------------------------------

<pre class='lang-javascript'>
// Inside RenderWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a block layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return ['x', 'y', 'position'] }

    layout(children, constraintSpace, styleMap, breakToken) {
        const absoluteChildren = [];
        const fixedChildren = [];
        const fragments = [];

        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        let width = resolveWidth(constraintSpace, styleMap.get('width'));

        // Create a new constraint space for our children to consume.
        let childConstraintSpace = new ConstraintSpace(constraintSpace);
        childConstraintSpace.width = width;

        // Track the used height, min and max content.
        let height = 0;
        let minContent = 0;
        let maxContent = 0;

        for (let child of children) {
            // Check if the child is out of flow positioned.
            const childPosition = child.styleMap.get('position');

            if (childPosition == 'absolute') {
                absoluteChildren.push(child);
                continue;
            }

            if (childPosition == 'fixed') {
                fixedChildren.push(child);
                continue;
            }

            // Layout the in flow child.
            const childFragment = child.doLayout(childConstraintSpace);

            // Position the child.
            childFragment.x = 0;
            childFragment.y = height;

            // Update our current height, min and max content.
            height += childFragment.height;
            minContent = Math.max(childFragment.minContent, minContent);
            maxContent = Math.max(childFragment.maxContent, maxContent);
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unPositionedChildren: absoluteChildren.concat(fixedChildren),
            breakToken: null
        };
    }
});
</pre>

<pre class='lang-markup'>
&lt;div id="myElement"&gt;
    &lt;div&gt;
        CSS is awesome.
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
#myElement {
    display: layout('simple-flow');
}
&lt;/style&gt;
</pre>

Example 2: A simple line layout {#example-2}
--------------------------------------------

<pre class='lang-javascript'>
// Inside RenderWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a inline layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-inline-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return [] }

    layout(children, constraintSpace, styleMap, breakToken) {
        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        const width = resolveWidth(constraintSpace, styleMap.get('width'));
        const fragments = [];
        let height = 0;

        // TODO compute these.
        let minContent = 0;
        let maxContent = 0;

        let childFragment = null;
        let lineFragments = [];
        let lineHeight = 0;
        let remainingLineWidth = width; // NOTE: should be helper on constraint space?

        const childIter = chidlren.values();
        let child = childIter.next().value;
        let breakToken = null;

        while (child) {
            // Create a new constraint space for the child, with all the current
            // positioned children.
            const childConstraintSpace = new ConstraintSpace(constraintSpace);
            childConstraintSpace.addExclusion(new ExclusionRect(width, height, 0, 0));
            childConstraintSpace.addExclusions(lineFragments);

            // Perform layout on the child.
            childFragment = child.doLayout(childConstraintSpace, breakToken);
            fragments.push(childFragment);

            // Check if we need to position the fragment on the next line.
            if (childFragment.width > remainingLineWidth) {
                // Need to start a new line.
                lineFragments = [];
                height += lineHeight;
                lineHeight = 0;
                remainingLineWidth = width;
            }

            // Position the fragment horizontally.
            childFragment.x = width - remainingLineWidth;

            lineFragments.push(childFragment);
            lineHeight = Math.max(lineHeight, childFragment.height);
            remainingLineWidth -= childFragment.width;

            // Update the line fragments positions, based on the new lineHeight.
            for (let frag of lineFragments) {
                frag.y = lineHeight - frag.height;
            }

            // Step to the next child if required.
            if (childFragment.breakToken) {
                breakToken = childFragment.breakToken;
            } else {
                child = childIter.next().value;
                breakToken = null;
            }
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unpositionedFragments: [],
            breakToken: null
        };
    }
});
</pre>
