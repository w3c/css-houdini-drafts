<pre class='metadata'>
Title:  CSS Layout API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-layout-api-1/
Shortname: css-layout-api
Level: 1
Abstract:
Editor: Greg Whitworth, gwhit@microsoft.com, w3cid 69511
Editor: Ian Kilpatrick, ikilpatrick@chromium.org, w3cid 73001
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Editor: Shane Stephens, shanestephens@google.com, w3cid 47691
Editor: Robert O'Callahan, robert@ocallahan.org
Editor: Rossen Atanassov, rossen.atanassov@microsoft.com, w3cid 49885
Ignored Terms: LayoutWorklet
Ignored Terms: create a workletglobalscope
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
    padding: .5em;
    border: thin solid #ddd; border-radius: .5em;
    margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
    margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
    margin-bottom: 0;
}
</style>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
spec:css-display-3; type:dfn; text:box
spec:css-display-3; type:value; for:display; text:none
spec:css-display-3; type:value; for:<display-inside>; text:grid
spec:css-display-3; type:value; for:<display-outside>; text:inline
spec:css-pseudo-4; type:selector; text:::after
spec:css-pseudo-4; type:selector; text:::before
spec:css-pseudo-4; type:selector; text:::first-letter
spec:css-pseudo-4; type:selector; text:::first-line
spec:dom; type:dfn; for:/; text:element
spec:infra; type:dfn; text:list
spec:html; type:dfn; for:global object; text:realm
spec:css22; type:property;
    text:max-height
    text:max-width
    text:min-height
    text:min-width
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: InvalidModificationError
    urlPrefix: #dfn-;
        url: throw; text: thrown
    urlPrefix: #idl-;
        text: boolean
        text: DOMException
    url: es-type-mapping; text: converting
    url: es-invoking-callback-functions; text: Invoke
urlPrefix: https://tc39.github.io/ecma262/#sec-; type: dfn;
    text: constructor
    text: Construct
    text: IsArray
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: ecmascript-data-types-and-values; text: type
    url: get-o-p; text: Get
    url: generatorfunction; text: generator function
    url: terms-and-definitions-function; text: function
    urlPrefix: native-error-types-used-in-this-standard-
        text: TypeError
urlPrefix: https://drafts.csswg.org/css-display-3/#; type: dfn
    text: flow layout
urlPrefix: https://drafts.csswg.org/css-sizing/#; type: dfn
    text: intrinsic sizes
urlPrefix: https://drafts.csswg.org/css-break/#; type: dfn
    text: fragmentation break
urlPrefix: https://www.w3.org/TR/CSS21/; type:dfn
    urlPrefix: box.html#;
        url: box-dimensions; text: box model edges
    urlPrefix: visudet.html#;
        text: static position
urlPrefix: https://html.spec.whatwg.org/#; type: dfn
    text: structuredserializeforstorage
    text: structureddeserialize
</pre>

Introduction {#intro}
=====================

<em>This section is not normative.</em>

The layout stage of CSS is responsible for generating and positioning <a>fragments</a> from the
<a>box tree</a>.

This specification describes an API which allows developers to layout a <a>box</a> in response to
computed style and <a>box tree</a> changes.

Layout API Containers {#layout-api-containers}
==============================================

A new <a href="https://www.w3.org/TR/css-values-3/#comb-one">alternative</a> value is added
to the <<display-inside>> production: <code>layout(<<ident>>)</code>.

<dl dfn-for="display" dfn-type=value>
    <dt><dfn>layout()</dfn>
    <dd>
        This value causes an element to generate a <a>layout API container</a> box.
</dl>

A <dfn>layout API container</dfn> is the box generated by an element with a <<display-inside>>
<a>computed value</a> ''layout()''.

A <a>layout API container</a> establishes a new <dfn>layout API formatting context</dfn> for its
contents. This is the same as establishing a block formatting context, except that the layout
provided by the author is used instead of the block layout.
For example, floats do not intrude into the layout API container, and the layout API container's
margins do not collapse with the margins of its contents.

All inflow children of a <a>layout API container</a> are called <dfn>layout API children</dfn> and
are laid out using the auther defined layout.

<a>Layout API containers</a> form a containing block for their contents
<a href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details">exactly like block
containers do</a>. [[!CSS21]]

Note: In a future level of the specification there may be a way to override the containing block
    behaviour.

The 'overflow' property applies to <a>layout API containers</a>. This is discussed in
[[#interaction-overflow]].

As the layout is entirely up to the author, properties which are used in other layout modes (e.g.
flex, block) may not apply. For example an author may not repect the 'margin' property on children.

Layout API Container Painting {#painting}
-----------------------------------------

<a>Layout API Container</a> children paint exactly the same as inline blocks [[!CSS21]], except that
the order in which they are returned from the layout method (via
{{FragmentResultOptions/childFragments}}) is used in place of raw document order, and 'z-index'
values other than ''z-index/auto'' create a stacking context even if 'position' is ''static''.

Box Tree Transformations {#layout-api-box-tree}
-----------------------------------------------

The <a>layout API children</a> can act in different ways depending on the value of <a for="document
layout definition">layout options'</a> {{LayoutOptions/childDisplay}} (set by
<code>layoutOptions</code> on the class).

If the value of <a for="document layout definition">layout options'</a>
{{LayoutOptions/childDisplay}} is <code>"block"</code> the 'display' value of that child is
<a>blockified</a>. This is similar to children of <a>flex containers</a> or <a>grid containers</a>.
See [[!css3-display]].

If the value of <a for="document layout definition">layout options'</a>
{{LayoutOptions/childDisplay}} is <code>"normal"</code>, no <a>blockification</a> occurs. Instead
children with a <<display-outside>> <a>computed value</a> of ''inline'' (a <a>root inline box</a>)
will produce a single {{LayoutFragment}} representing each line when
{{LayoutChild/layoutNextFragment()}} is called.

Note: This allows authors to adjust the available inline size of each line, and position each line
    separately.

Children of a {{LayoutChild}} which represents <a>root inline box</a> also have some additional
transformations.

 - A <a>block-level</a> box inside a <a>inline-level</a> box is <a>inlinified</a> I.e. its
     <<display-outside>> is set to ''inline''.

 - A <a>float</a> inside a <a>inline-level</a> box is not taken out of flow. Instead it must be
     treated as inflow, and be <a>inlinified</a>.

In both of the above cases the children become <a>atomic inlines</a>.

Note: User agents would not perform any "inline splitting" or fragmenting when they encounter a
    <a>block-level</a> box.

<div class="note">
    Note: In the example below "inline-span" would be represented as a single {{LayoutChild}} with
    both "block" and "float" being <a>atomic inlines</a>.
    <pre class="lang-html">
        &lt;span id="inline-span">
          Text
          &lt;div id="block">&lt;/div>
          &lt;div id="float">&lt;/div>
          Text
        &lt;/span>
    </pre>
</div>

Layout API Model and Terminology {#layout-api-model-and-terminology}
====================================================================

This section gives an overview of the Layout API given to authors.

The <dfn>current layout</dfn> is the layout algorithm for the <a>box</a> we are currently performing
layout for.

The <dfn>parent layout</dfn> is the layout algorithm for the <a>box's</a> direct parent, (the layout
algorithm which is requesting the <a>current layout</a> to be performed).

A <dfn>child layout</dfn> is the layout algorithm for a {{LayoutChild}} of the <a>current layout</a>.

Layout Children {#layout-children}
----------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutChild {
    readonly attribute StylePropertyMapReadOnly styleMap;

    IntrinsicSizesRequest intrinsicSizes();
    LayoutFragmentRequest layoutNextFragment(LayoutConstraints constraints, ChildBreakToken breakToken);
};
</pre>

A {{LayoutChild}} represents either a CSS generated <a>box</a> before layout has occured. (The box
or boxes will all have a computed value of 'display' that is not ''none'').

The {{LayoutChild}} does not contain any layout information itself (like inline or block size) but
can be used to generate {{LayoutFragment}}s which do contain layout information.

An author cannot construct a {{LayoutChild}} with this API, this happens at a separate stage of the
rendering engine (post style resolution).

The {{LayoutChild}} has computed style which can be accessed by {{LayoutChild/styleMap}}. The
{{LayoutChild/styleMap}} will only contain properties which are listed in the child input properties
array.

A {{LayoutChild}} could be generated by:

 - An <a>element</a>.

 - A <a>root inline box</a>.

 - A <a>::before</a> or <a>::after</a> pseudo-element.

    Note: Other pseudo-elements such as <a>::first-letter</a> or <a>::first-line</a> do not generate
        a {{LayoutChild}} for layout purposes. They are additional styling information for a text
        node.

 - An <a>anonymous box</a>. For example an anonymous box may be inserted as a result of:

    - A text node which has undergone <a>blockification</a>. (Or more generally a <a>root inline
        box</a> which has undergone <a>blockification</a>).

    - An element with ''display: table-cell'' which doesn't have a parent with ''display: table''.

<div class="note">
    Note: As an example the following would be placed into three {{LayoutChild}}ren:
    <pre class="lang-html">
        &lt;style>
          #box::before { content: 'hello!'; }
        &lt;/style>
        <!-- A ::before pseudo-element is inserted here. -->
        &lt;div id="box">A block level box with text.&lt;/div>
        &lt;img src="..." />
    </pre>
</div>

<div class="note">
    Note: As an example the following would be placed into a single {{LayoutChild}} as they share a
    <a>root inline box</a>:
    <pre class="lang-html">
        This is a next node, &lt;span>with some additional styling,
        that may&lt;/span> break over&lt;br>multiple lines.
    </pre>
</div>

Multiple non-<a>atomic inlines</a> are placed within the same {{LayoutChild}} to allow rendering
engines to perform text shaping across element boundaries.

<div class="note">
    Note: As an example the following should produce one {{LayoutFragment}} but is from
    three non-<a>atomic inlines</a>:
    <pre class="lang-html">
        &#x639;&lt;span style="color: blue">&#x639;&lt;/span>&#x639;
    </pre>
</div>

Note: In a future level of the specification there may be a way to query the computed style
      of <a>inline boxes</a> inside a <a>root inline box</a> represented by a {{LayoutChild}}.

An array of {{LayoutChild}}ren is passed into the layout method which represents the children of the
current box which is being laid out.

To perform layout on a box the author can invoke the {{LayoutChild/layoutNextFragment()}} method.
This will produce a {{LayoutFragment}} which contains layout information.

The {{LayoutChild/layoutNextFragment()}} method may be invoked multiple times with different
arguments to query the {{LayoutChild}} for different layout information.

Layout Fragments {#layout-fragments}
------------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutFragment {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    attribute double inlineOffset;
    attribute double blockOffset;

    readonly attribute any data;

    readonly attribute ChildBreakToken? breakToken;
};
</pre>

A {{LayoutFragment}} represents a CSS <a>fragment</a> of a {{LayoutChild}} after layout has occurred
on that child. This is produced by the {{LayoutChild/layoutNextFragment()}} method.

The {{LayoutFragment}} has {{LayoutFragment/inlineSize}} and {{LayoutFragment/blockSize}}
attributes, which are set by the respective child's layout algorithm. They cannot be changed. If the
<a>current layout</a> requires a different {{LayoutFragment/inlineSize}} or
{{LayoutFragment/blockSize}} the author must perform {{LayoutChild/layoutNextFragment()}} again with
different arguments in order to get different results.

The author inside the current layout can position a resulting {{LayoutFragment}} by setting its
{{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}} attributes. If not set by the
author they default to zero. The {{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}}
attributes represent the position of the {{LayoutFragment}} relative to its parent's border box,
before transform or positioning (e.g. if a fragment is <a>relatively positioned</a>) has been
applied.

<div class="example">
The layout algorithm performs a block-like layout (positioning fragments sequentially in the block
direction), while centering its children in the inline direction.

<pre class="lang-javascript">
registerLayout('block-like', class {
    *intrinsicSizes(children, edges, styleMap) {
      const childrenSizes = yield children.map((child) => {
          return child.intrinsicSizes();
      });

      const maxContentSize = childrenSizes.reduce((max, childSizes) => {
          return Math.max(max, childSizes.maxContentContribution);
      }, 0) + edges.all.inline;

      const minContentSize = childrenSizes.reduce((max, childSizes) => {
          return Math.max(max, childSizes.minContentContribution);
      }, 0) + edges.all.inline;

      return {maxContentSize, minContentSize};
    }

    *layout(children, edges, constraints, styleMap) {
        const availableInlineSize = constraints.fixedInlineSize - edges.all.inline;
        const availableBlockSize = (constraints.fixedBlockSize || Infinity) - edges.all.block;

        const childFragments = [];
        const childConstraints = { availableInlineSize, availableBlockSize };

        const childFragments = yield children.map((child) => {
            return child.layoutNextFragment(childConstraints);
        });

        let blockOffset = edges.all.blockStart;
        for (let fragment of childFragments) {
            // Position the fragment in a block like manner, centering it in the
            // inline direction.
            fragment.blockOffset = blockOffset;
            fragment.inlineOffset = Math.max(
                edges.all.inlineStart,
                (availableInlineSize - fragment.inlineSize) / 2);

            blockOffset += fragment.blockSize;
        }

        const autoBlockSize = blockOffset + edges.all.blockEnd;

        return {
            autoBlockSize,
            childFragments,
        };
    }
});
</pre>
</div>

A <a>layout API container</a> can communicate with other <a>layout API containers</a> by using the
{{LayoutFragment/data}} attribute. This is set by the {{FragmentResultOptions/data}} member in the
{{FragmentResultOptions}} dictionary.

The {{LayoutFragment}}'s {{LayoutFragment/breakToken}} specifies where the {{LayoutChild}} last
fragmented. If the {{LayoutFragment/breakToken}} is null the {{LayoutChild}} wont produce any more
{{LayoutFragment}}s for that token chain. The {{LayoutFragment/breakToken}} can be passed to the
{{LayoutChild/layoutNextFragment()}} function to produce the next {{LayoutFragment}} for a
particular child. The {{LayoutFragment/breakToken}} cannot be changed.
If the <a>current layout</a> requires a different {{LayoutFragment/breakToken}} the author must perform
{{LayoutChild/layoutNextFragment()}} again with different arguments.

Note: In a future level of the specification there may be a way to query for additional baseline
      information, for example where the alphabetic or center baseline is positioned.

Layout Constraints {#layout-constraints}
----------------------------------------

<pre class='idl'>
[Constructor(optional LayoutConstraintsOptions options),Exposed=LayoutWorklet]
interface LayoutConstraints {
    readonly attribute double availableInlineSize;
    readonly attribute double availableBlockSize;

    readonly attribute double? fixedInlineSize;
    readonly attribute double? fixedBlockSize;

    readonly attribute double percentageInlineSize;
    readonly attribute double percentageBlockSize;

    readonly attribute double? blockFragmentationOffset;
    readonly attribute BlockFragmentationType blockFragmentationType;

    readonly attribute any data;
};

dictionary LayoutConstraintsOptions {
    double availableInlineSize = 0;
    double availableBlockSize = 0;

    double fixedInlineSize;
    double fixedBlockSize;

    double percentageInlineSize;
    double percentageBlockSize;

    double blockFragmentationOffset;
    BlockFragmentationType blockFragmentationType = "none";

    any data;
};

enum BlockFragmentationType { "none", "page", "column", "region" };
</pre>

A {{LayoutConstraints}} object is passed into the layout method which represents the all the
constraints for the <a>current layout</a> to perform layout inside. It is also used to pass
information about the available space into a <a>child layout</a>.

The {{LayoutConstraints}} object has {{LayoutConstraints/availableInlineSize}} and
{{LayoutConstraints/availableBlockSize}} attributes. This represents the <a>available space</a> for
a {{LayoutFragment}} which the layout should respect.

Note: Some layouts may need to produce a {{LayoutFragment}} which exceed this size. For example a
    <a>replaced element</a>. The <a>parent layout</a> should expect this to occur and deal with it
    appropriately.

A <a>parent layout</a> may require the <a>current layout</a> to be exactly a particular size. If
the {{LayoutConstraints/fixedInlineSize}} or {{LayoutConstraints/fixedBlockSize}} are specified the
<a>current layout</a> should produce a {{LayoutFragment}} with a the specified size in the
appropriate direction.

<div class="example">
The layout algorithm performs a flexbox-like distribution of spare space in the inline direction. It
creates child layout constraints which specify that a child should be a fixed inline size.

<pre class="lang-javascript">
registerLayout('flex-distribution-like', class {
    *intrinsicSizes(children, edges, styleMap) {
      const childrenSizes = yield children.map((child) => {
          return child.intrinsicSizes();
      });

      const maxContentSize = childrenSizes.reduce((sum, childSizes) => {
          return sum + childSizes.maxContentContribution;
      }, 0) + edges.all.inline;

      const minContentSize = childrenSizes.reduce((max, childSizes) => {
          return sum + childSizes.minContentContribution;
      }, 0) + edges.all.inline;

      return {maxContentSize, minContentSize};
    }

    *layout(children, edges, constraints, styleMap) {

        const availableInlineSize =
            constraints.fixedInlineSize - edges.all.inline;
        const availableBlockSize =
            (constraints.fixedInlineSize || Infinity) - edges.all.block;

        const childConstraints = { availableInlineSize, availableBlockSize };

        const unconstrainedChildFragments = yield children.map((child) => {
            return child.layoutNextFragment(childConstraints);
        });

        const unconstrainedSizes = [];
        const totalSize = unconstrainedChildFragments.reduce((sum, fragment, i) => {
            unconstrainedSizes[i] = fragment.inlineSize;
            return sum + fragment.inlineSize;
        }, 0);

        // Distribute spare space between children.
        const remainingSpace = Math.max(0, inlineSize - totalSize);
        const extraSpace = remainingSpace / children.length;

        const childFragments = yield children.map((child, i) => {
            return child.layoutNextFragment({
                fixedInlineSize: unconstrainedSizes[i] + extraSpace,
                availableBlockSize
            });
        });

        // Position the fragments.
        let inlineOffset = 0;
        let maxChildBlockSize = 0;
        for (let fragment of childFragments) {
            fragment.inlineOffset = inlineOffset;
            fragment.blockOffset = edges.all.blockStart;

            inlineOffset += fragment.inlineSize;
            maxChildBlockSize = Math.max(maxChildBlockSize, fragment.blockSize);
        }

        return {
            autoBlockSize: maxChildBlockSize + edges.all.block,
            childFragments,
        };
    }
});
</pre>
</div>

The {{LayoutConstraints}} object has {{LayoutConstraints/percentageInlineSize}} and
{{LayoutConstraints/percentageBlockSize}} attributes. These represent the size that a layout
percentages should be resolved against while performing layout.

The {{LayoutConstraints}} has a {{LayoutConstraints/blockFragmentationType}} attribute. The
<a>current layout</a> should produce a {{LayoutFragment}} which fragments at the
{{LayoutConstraints/blockFragmentationOffset}} if possible. 

The <a>current layout</a> can choose not to fragment a {{LayoutChild}} based on the
{{LayoutConstraints/blockFragmentationType}}, for example if the child has a property like
''break-inside: avoid-page;''.

Breaking and Fragmentation {#breaking-and-fragmentation}
--------------------------------------------------------

<pre class="idl">
[Exposed=LayoutWorklet]
interface ChildBreakToken {
    readonly attribute BreakType breakType;
    readonly attribute LayoutChild child;
};

[Exposed=LayoutWorklet]
interface BreakToken {
    readonly attribute sequence&lt;ChildBreakToken> childBreakTokens;
    readonly attribute any data;
};

dictionary BreakTokenOptions {
    sequence&lt;ChildBreakToken> childBreakTokens;
    any data = null;
};

enum BreakType { "none", "line", "column", "page", "region" };
</pre>

A {{LayoutChild}} can produce multiple {{LayoutFragment}}s. A {{LayoutChild}} may fragment in the
block direction if a {{LayoutConstraints/blockFragmentationType}} is not none.  Additionally
{{LayoutChild}} which represents <a>inline-level</a> content, may fragment line by line if the
<a for="document layout definition">layout options'</a> {{LayoutOptions/childDisplay}} (set by
<code>layoutOptions</code>) is <code>"normal"</code>.

A subsequent {{LayoutFragment}} is produced by using the previous {{LayoutFragment}}'s
{{LayoutFragment/breakToken}}. This tells the <a>child layout</a> to produce a {{LayoutFragment}}
starting at the point encoded in the {{ChildBreakToken}}.

Issue: Explain resuming the author defined layout.

<div class="example">
This example shows a simple layout which indents child fragments for a certain number of
lines.

This example also demonstrates using the previous {{LayoutFragment/breakToken}} of a
{{LayoutFragment}} to produce the next fragment for the {{LayoutChild}}.

It also demonstrates using the {{BreakToken}} to respect the {{LayoutConstraints}}'
{{LayoutConstraints/blockFragmentationType}}, it resumes it layout from the previous {{BreakToken}}.
It returns a {{FragmentResultOptions}} with a {{FragmentResultOptions/breakToken}} which is used to
resume the layout.

<pre class="lang-javascript">
registerLayout('indent-lines', class {
    static layoutOptions = {childDisplay: 'normal'};
    static inputProperties = ['--indent', '--indent-lines'];

    *layout(children, edges, constraints, styleMap, breakToken) {

        // Determine our (inner) available size.
        const availableInlineSize =
            constraints.fixedInlineSize - edges.all.inline;
        const availableBlockSize =
            (constraints.fixedBlockSize || Infinity) - edges.all.block;

        // Detrermine the number of lines to indent, and the indent amount.
        const indent = resolveLength(constraints, styleMap.get('--indent'));
        let lines = styleMap.get('--indent-lines').value;

        const childFragments = [];

        let childBreakToken = null;
        if (breakToken) {
            childBreakToken = breakToken.childBreakTokens[0];

            // Remove all the children we have already produced fragments for.
            children.splice(0, children.indexOf(childBreakToken.child));
        }

        let blockOffset = edges.all.blockStart;
        let child = children.shift();
        while (child) {
            const shouldIndent = lines-- > 0;

            // Adjust the inline size for the indent.
            const childAvailableInlineSize = shouldIndent ?
                availableInlineSize - indent : availableInlineSize;

            const childConstraints = {
                availableInlineSize: childAvailableInlineSize,
                availableBlockSize,
                percentageInlineSize: availableInlineSize,
                blockFragmentationType: constraints.blockFragmentationType,
            };

            const fragment = yield child.layoutNextFragment(childConstraints,
                                                            childBreakToken);
            childFragments.push(fragment);

            // Position the fragment.
            fragment.inlineOffset = shouldIndent ?
                edges.all.inlineStart + indent : edges.all.inlineStart;
            fragment.blockOffset = blockOffset;
            blockOffset += fragment.blockSize;

            // Check if we have gone over the block fragmentation limit.
            if (constraints.blockFragmentationType != 'none' &&
                blockOffset > constraints.blockSize) {
                break;
            }

            if (fragment.breakToken) {
                childBreakToken = fragment.breakToken;
            } else {
                // If a fragment doesn't have a break token, we move onto the
                // next child.
                child = children.shift();
                childBreakToken = null;
            }
        }

        const autoBlockSize = blockOffset + edges.all.blockEnd;

        // Return our fragment.
        const result = {
            autoBlockSize,
            childFragments: childFragments,
        }

        if (childBreakToken) {
            result.breakToken = {
                childBreakTokens: [childBreakToken],
            };
        }

        return result;
    }
});
</pre>
</div>

Edges {#edges}
--------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutEdgeSizes {
  readonly attribute double inlineStart;
  readonly attribute double inlineEnd;

  readonly attribute double blockStart;
  readonly attribute double blockEnd;

  // Convenience attributes for the sum in one direction.
  readonly attribute double inline;
  readonly attribute double block;
};

[Exposed=LayoutWorklet]
interface LayoutEdges {
  readonly attribute LayoutEdgeSizes border;
  readonly attribute LayoutEdgeSizes scrollbar;
  readonly attribute LayoutEdgeSizes padding;

  readonly attribute LayoutEdgeSizes all;
};
</pre>

A {{LayoutEdges}} object is passed into the layout method. This represents the size of the <a>box
model edges</a> for the current box which is being laid out.

The {{LayoutEdges}} has {{LayoutEdges/border}}, {{LayoutEdges/scrollbar}}, and
{{LayoutEdges/padding}} attributes. Each of these represent the width of their respective edge.

The {{LayoutEdges}} has the {{LayoutEdges/all}} attribute. This is a convenience attribute which
represents the sum of the {{LayoutEdges/border}}, {{LayoutEdges/scrollbar}}, {{LayoutEdges/padding}}
edges.

The {{LayoutEdgeSizes}} object represents the width in CSS pixels of an edge in each of the
<a>abstract dimensions</a> ({{LayoutEdgeSizes/inlineStart}}, {{LayoutEdgeSizes/inlineEnd}},
{{LayoutEdgeSizes/blockStart}}, {{LayoutEdgeSizes/blockEnd}}).

The {{LayoutEdgeSizes/inline}}, and {{LayoutEdgeSizes/block}} on the {{LayoutEdgeSizes}} object are
convenience attributes which represent the sum in that direction.

<div class="example">
This example shows an node styled by CSS, and what its respective {{LayoutEdges}} could contain.

<pre class="lang-html">
&lt;style>
.container {
  width: 50px;
  height: 50px;
}

.box {
  display: layout(box-edges);

  padding: 10%;
  border: solid 2px;
  overflow-y: scroll;
}
&lt;/style>

&lt;div class="container">
  &lt;div class="box">&lt;/div>
&lt;/div>
</pre>

<pre class="lang-javascript">
registerLayout('box-edges', class {
    *layout(children, edges, constraints, styleMap, breakToken) {
        edges.padding.inlineStart; // 5 (as 10% * 50px = 5px).
        edges.border.blockEnd; // 2
        edges.scrollbar.inlineEnd; // UA-dependent, may be 0 or >0 (e.g. 16).
        edges.all.block; // 14 (2 + 5 + 5 + 2).
    }
}
</pre>
</div>

Interactions with other Modules {#interactions-with-other-modules}
==================================================================

This section describes how other CSS modules interact with the CSS Layout API.

Sizing {#interaction-sizing}
----------------------------

User agents must use the {{LayoutConstraints}} object to communicate to the <a>current layout</a>
the size they would like the fragment to be.

If the user agent wishes to force a size on the box, it can use the
{{LayoutConstraints/fixedInlineSize}} and {{LayoutConstraints/fixedBlockSize}} attributes to do so.

The <a>layout API container</a> can be passed size information in different ways depending on the
value of <a for="document layout definition">layout options'</a> {{LayoutOptions/sizing}} (set by
<code>layoutOptions</code> on the class).

If the value of <a for="document layout definition">layout options'</a> {{LayoutOptions/sizing}} is
<code>"block-like"</code>, then the {{LayoutConstraints}} passed to the <a>layout API container</a>:
    - <em>Must</em> calculate and set {{LayoutConstraints/fixedInlineSize}} based off the rules
        specified in [[!css-sizing-3]] and the formatting context in which it participates, e.g.

        - As a <a>block-level</a> box in a <a>block formatting context</a>, it is sized like a
            <a>block box</a> that establishes a formatting context, with an ''width/auto'' <a>inline
            size</a> calculated as for non-replaced block boxes.

        - As an <a>inline-level</a> box in an <a>inline formatting context</a>, it is sized as an
            atomic inline-level box (such as an inline-block).

    - <em>Must</em> calculate and set {{LayoutConstraints/fixedBlockSize}} based off the rules
        specified in [[!css-sizing-3]], and the formatting context in which it participates. If the
        <a>layout API container</a> has an ''height/auto'' <a>block size</a>, and cannot be determined
        ahead of time, {{LayoutConstraints/fixedBlockSize}} must be set to <code>null</code>.

If the value of <a for="document layout definition">layout options'</a> {{LayoutOptions/sizing}} is
<code>"manual"</code>, then the user-agent shouldn't pre-calculate
{{LayoutConstraints/fixedInlineSize}} and/or {{LayoutConstraints/fixedBlockSize}} ahead of time,
except when it is being forced to a particular size by the formatting context in which it
participates, for example:

    - If the <a>layout API container</a> is within a <a>block formatting context</a>, is inflow, and
        has an ''width/auto'' inline size, the user agent <em>must</em> set the
        {{LayoutConstraints/fixedInlineSize}} to the <a>stretch-fit inline size</a>.

<div class="note">
    Note: In the example below the <a>layout API container</a> has its inline size set to 50.

    <pre class="lang-html">
        &lt;style>
          #container {
            width: 100px;
            height: 100px;
            box-sizing: border-box;
            padding: 5px;
          }
          #layout-api {
            display: layout(foo);
            margin: 0 20px;
          }
        &lt;/style>
        &lt;div id="container">
          &lt;div id="layout-api">&lt;/div>
        &lt;/div>
    </pre>
</div>

### Positioned layout sizing ### {#interaction-sizing-positiong-layout}

If a <a>layout API container</a> is out-of-flow positioned the user agent <em>must</em> solve the
positioned size equations ([[css-position-3#abs-non-replaced-width]],
[[css-position-3#abs-non-replaced-height]]), and set the appropriate
{{LayoutConstraints/fixedInlineSize}} and {{LayoutConstraints/fixedBlockSize}}.

<div class="note">
    Note: In the example below the <a>layout API container</a> has its inline and block size fixed
        to 80.

    <pre class="lang-html">
        &lt;style>
          #container {
            position: relative;
            width: 100px;
            height: 100px;
          }
          #layout-api {
            display: layout(foo);
            top: 10px;
            bottom: 10px;
            left: 10px;
            right: 10px;
            position: absolute;
          }
        &lt;/style>
        &lt;div id="container">
          &lt;div id="layout-api">&lt;/div>
        &lt;/div>
    </pre>
</div>

Positioning {#interaction-positioning}
--------------------------------------

All positioning in this level of the specification is handled by the user agent.

As a result:
  - Out-of-flow children do not appear as {{LayoutChild}}ren.

  - <a>Layout API containers</a> establish <a>containing blocks</a> <a
      href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details">exactly like block
      containers do</a>. [[!CSS21]]

  - The {{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}} represent the position of
      the fragment before any positioning and transforms have occured.

  - The <a>static position</a> of an absolutely-positioned child of a <a>layout API container</a> is
      set to the <a>inline-start</a>, <a>block-start</a> padding edge of the <a>layout API
      container</a>. Auto margins are treated as zero for the child.

<div class="note">
    Note: In the example below:
      - "child-relative" would be the only child passed to the author's layout. If it was positioned
          at ({{LayoutFragment/inlineOffset}} <code>= 20</code>, {{LayoutFragment/blockOffset}}
          <code> = 30</code>), its final position would be (<code>25</code>, <code>40</code>) as the
          relative positioning was handled by the user agent.

      - "child-absolute" would not appear as a {{LayoutChild}}, and instead would be laid out and
          positioned by the user agent.

      - The examples above also apply in a similar way to sticky and fixed positioned children.

    <pre class="lang-html">
        &lt;style>
          #container {
            display: layout(foo);
            position: relative; /* container is a containing block */
            width: 100px;
            height: 100px;
          }
          #child-relative {
            position: relative;
            left: 5px;
            top: 10px;
          }
        &lt;/style>
        &lt;div id="container">
          &lt;div id="child-relative">&lt;/div>
          &lt;div id="child-absolute">&lt;/div>
        &lt;/div>
    </pre>
</div>

Overflow {#interaction-overflow}
--------------------------------

The <a>scrollable overflow</a> for a <a>layout API container</a> is handled by the user agent in
this level of the specification.

A <a>layout API container</a> should calculate its scrollable overflow exactly like block
containers do.

Even if the author's <a>layout API container</a> positions a fragment into the <a>scrollable
overflow</a> region, relative positioning or transforms may cause the fragment to shift such that
its <a>scrollable overflow</a> region, causing no overflow to occur.

Fragmentation {#interaction-fragmentation}
------------------------------------------

A <a>parent layout</a> can ask the <a>current layout</a> to <a>fragment</a> by setting the
{{LayoutConstraints/blockFragmentationType}} and {{LayoutConstraints/blockFragmentationOffset}}.

E.g. [[css-multicol-1]] layout would set a {{LayoutConstraints/blockFragmentationType}} to
<code>"column"</code> and set the {{LayoutConstraints/blockFragmentationOffset}} to where it needs the
child to fragment.

Alignment {#interaction-alignment}
----------------------------------

<div class="issue">
Issue: We need to add the ability to request baselines on the input layout constraints, and have a
    fragment returned what was asked. E.g.

<pre class="lang-javascript">
const constraints = {
    inlineSize: availableInlineSize,
    baselines: ['alphabetic', 'middle'],
};

const fragment = yield child.layoutNextFragment(constraints);
fragment.baselines.get('alphabetic') == /* something */;
</pre>

Do we want this in level 1? E.g. is it better to wait for implementations of [[css-align-3]] before
doing this?
</div>

Layout {#layout}
================

This section describes how the CSS Layout API interacts with the user agent's layout engine.

Layout Invalidation {#layout-invalidation}
------------------------------------------

A <a>document</a> has an associated <dfn>layout name to input properties map</dfn> and a <dfn>layout
name to child input properties map</dfn>. Initially these maps are empty and are populated when
{{registerLayout(name, layoutCtor)}} is called.

Each <a>box</a> has an associated <dfn>layout valid flag</dfn>. It may be either
<dfn>layout-valid</dfn> or <dfn>layout-invalid</dfn>. It is initially set to <a>layout-invalid</a>.

Each <a>box</a> has an associated <dfn>intrinsic sizes valid flag</dfn>. If may be either
<dfn>intrinsic-sizes-valid</dfn> or <dfn>intrinsic-sizes-invalid</dfn>. It is initially set to
<a>intrinsic-sizes-invalid</a>.

When the computed style for a |box| changes, the user agent must run the following steps:
    1. Let |layoutFunction| be the ''layout()'' function of the 'display' property on the computed
        style for the |box| if it exists. If it is a different type of value (e.g.  ''grid'') then
        abort all these steps.

    2. Let |name| be the first argument of the |layoutFunction|.

    3. Let |inputProperties| be the result of looking up |name| on <a>layout name to input
        properties map</a>.

    4. Let |childInputProperties| be the result of looking up |name| on <a>layout name to child
        input properties map</a>.

    5. For each |property| in |inputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>, and
        set the <a>intrinsic sizes valid flag</a> to <a>intrinsic-sizes-invalid</a>.

    6. For each |property| in |childInputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>, and
        set the <a>intrinsic sizes valid flag</a> to <a>intrinsic-sizes-invalid</a>.

When a child <a>box</a> represented by a {{LayoutChild}} is added or removed from the <a>box
tree</a> or has its layout invalidated (from a computed style change, or a descentdant change). Set
the <a>layout valid flag</a> on the current <a>box</a> to <a>layout-invalid</a> and set the
<a>intrinsic sizes valid flag</a> on the current <a>box</a> to <a>intrinsic-sizes-invalid</a>.

Note: This only describes layout invalidation as it relates to the CSS Layout API. All
    <a>boxes</a> conceptually have a <a>layout valid flag</a> and these changes are propagated
    through the <a>box tree</a>.

Issue: We also want to implcitly invalidate on size and edge properties, i.e.
    - 'width', 'min-width', 'max-width'
    - 'height', 'min-height', 'max-height'
    - 'padding-top', 'padding-bottom', 'padding-left', 'padding-right'
    - 'border-top-width', 'border-bottom-width', 'border-left-width', 'border-right-width'
    - 'overflow', 'overflow-x', 'overflow-y'

Concepts {#concepts}
--------------------

A <dfn>layout definition</dfn> is a <a>struct</a> which describes the information needed by the
{{LayoutWorkletGlobalScope}} about hte author defined layout (which can be referenced by the
''layout()'' function). It consists of:

 - <dfn for="layout definition">class constructor</dfn> which is the class <a>constructor</a>.

 - <dfn for="layout definition">layout generator function</dfn> which is the layout <a>generator
     function</a> callback.

 - <dfn for="layout definition">intrinsic sizes generator function</dfn> which is the intrinsic sizes
     <a>generator function</a> callback.

 - <dfn for="layout definition">constructor valid flag</dfn>.

 - <dfn for="layout definition">input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>

 - <dfn for="layout definition">child input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>.

 - <dfn for="layout definition">layout options</dfn> a {{LayoutOptions}}.

A <dfn>document layout definition</dfn> is a <a>struct</a> which describes the information needed by
the <a>document</a> about the author defined layout (which can be referenced by the ''layout()''
function). It consists of:

 - <dfn for="document layout definition">input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>

 - <dfn for="document layout definition">child input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>.

 - <dfn for="document layout definition">layout options</dfn> a {{LayoutOptions}}.

Layout Worklet {#layout-worklet}
--------------------------------

The {{layoutWorklet}} attribute allows access to the {{Worklet}} responsible for all the classes
which are related to layout.

The {{layoutWorklet}}'s <a>worklet global scope type</a> is {{LayoutWorkletGlobalScope}}.

<pre class='idl'>
partial interface CSS {
    [SameObject] readonly attribute Worklet layoutWorklet;
};
</pre>

The {{LayoutWorkletGlobalScope}} is the global execution context of the {{layoutWorklet}}.

<pre class='idl'>
[Global=(Worklet,LayoutWorklet),Exposed=LayoutWorklet]
interface LayoutWorkletGlobalScope : WorkletGlobalScope {
    void registerLayout(DOMString name, VoidFunction layoutCtor);
};
</pre>

Registering A Layout {#registering-layout}
------------------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
dictionary LayoutOptions {
  ChildDisplayType childDisplay = "block";
  LayoutSizingMode sizing = "block-like";
};

[Exposed=LayoutWorklet]
enum ChildDisplayType {
    "block",
    "normal",
};

[Exposed=LayoutWorklet]
enum LayoutSizingMode {
    "block-like",
    "manual",
};
</pre>

Issue: "normal" is a bad name?

The <a>document</a> has a <a>map</a> of <dfn>document layout definitions</dfn>. Initially this map
is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

The {{LayoutWorkletGlobalScope}} has a <a>map</a> of <dfn>layout definitions</dfn>. Initially this
map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

The {{LayoutWorkletGlobalScope}} has a <a>map</a> of <dfn>layout class instances</dfn>. Initially
this map is empty; it is populated when the user agent calls either <a>determine the intrinsic
sizes</a> or <a>generate a fragment</a> for a <a>box</a>.

<div algorithm>
When the <dfn method for=LayoutWorkletGlobalScope>registerLayout(|name|, |layoutCtor|)</dfn> method
is called, the user agent <em>must</em> run the following steps:
    1. If the |name| is an empty string, <a>throw</a> a <a>TypeError</a> and abort all these steps.

    2. Let |layoutDefinitionMap| be {{LayoutWorkletGlobalScope}}'s <a>layout definitions</a> map.

    3. If |layoutDefinitionMap|[|name|] <a for=map>exists</a> <a>throw</a> a
        "<a>InvalidModificationError</a>" <a>DOMException</a> and abort all these steps.

    4. Let |inputProperties| be an empty <code>sequence&lt;DOMString></code>.

    5. Let |inputPropertiesIterable| be the result of <a>Get</a>(|layoutCtor|, "inputProperties").

    6. If |inputPropertiesIterable| is not undefined, then set |inputProperties| to the result of
        <a>converting</a> |inputPropertiesIterable| to a <code>sequence&lt;DOMString></code>. If an
        exception is <a>thrown</a>, rethrow the exception and abort all these steps.

        Note: The list of CSS properties provided by the input properties getter can either be
            custom or native CSS properties.

        Note: The list of CSS properties may contain shorthands.

        Note: In order for a layout class to be forwards compatible, the list of CSS properties can
            also contains currently invalid properties for the user agent. For example
            <code>margin-bikeshed-property</code>.

    7. Let |childInputProperties| be an empty <code>sequence&lt;DOMString></code>.

    8. Let |childInputPropertiesIterable| be the result of <a>Get</a>(|layoutCtor|,
        "childInputProperties").

    9. If |childInputPropertiesIterable| is not undefined, then set |childInputProperties| to the
        result of <a>converting</a> |childInputPropertiesIterable| to a
        <code>sequence&lt;DOMString></code>. If an exception is <a>thrown</a>, rethrow the exception
        and abort all these steps.

    10. Let |layoutOptionsValue| be the result of <a>Get</a>(|layoutCtor|, "layoutOptions").

    11. Let |layoutOptions| be the result of <a>converting</a> |layoutOptionsValue| to a
        {{LayoutOptions}}. If an exception is <a>thrown</a>, rethrow the exception and abort all
        these steps.

    12. If the result of <a>IsConstructor</a>(|layoutCtor|) is false, <a>throw</a> a
        <a>TypeError</a> and abort all these steps.

    13. Let |prototype| be the result of <a>Get</a>(|layoutCtor|, "prototype").

    14. If the result of <a>Type</a>(|prototype|) is not Object, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    15. Let |layout| be the result of <a>Get</a>(|prototype|, <code>"layout"</code>).

    16. If the result of <a>IsCallable</a>(|layout|) is false, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    17. If |layout|'s <code>\[[FunctionKind]]</code> internal slot is not <code>"generator"</code>,
        <a>throw</a> a <a>TypeError</a> and abort all these steps.

    18. Let |intrinsicSizes| be the result of <a>Get</a>(|prototype|,
        <code>"intrinsicSizes"</code>).

    19. If the result of <a>IsCallable</a>(|intrinsicSizes|) is false, <a>throw</a> a
        <a>TypeError</a> and abort all these steps.

    20. If |intrinsicSizes|'s <code>\[[FunctionKind]]</code> internal slot is not
        <code>"generator"</code>, <a>throw</a> a <a>TypeError</a> and abort all these steps.

    21. Let |definition| be a new <a>layout definition</a> with:

        - <a>class constructor</a> being |layoutCtor|.

        - <a>layout generator function</a> being |layout|.

        - <a>intrinsic sizes generator function</a> being |intrinsicSizes|.

        - <a>constructor valid flag</a> being <b>true</b>.

        - <a for="layout definition">input properties</a> being |inputProperties|.

        - <a for="layout definition">child input properties</a> being |childInputProperties|.

        - <a for="layout definition">layout options</a> being |layoutOptions|.

    22. <a for=map>Set</a> |layoutDefinitionMap|[|name|] to |definition|.

    23. <a>Queue a task</a> to run the following steps:

        1. Let |documentLayoutDefinitionMap| be the associated <a>document's</a> <a>document layout
            definitions</a> <a>map</a>.

        2. Let |documentDefinition| be a new <a>document layout definition</a> with:

            - <a for="document layout definition">input properties</a> being |inputProperties|.

            - <a for="document layout definition">child input properties</a> being
                |childInputProperties|.

            - <a for="document layout definition">layout options</a> being |layoutOptions|.

        3. If |documentLayoutDefinitionMap|[|name|] <a for=map>exists</a>, run the following steps:

            1. Let |existingDocumentDefinition| be the result of <a for=map>get</a>
                |documentLayoutDefinitionMap|[|name|].

            2. If |existingDocumentDefinition| is <code>"invalid"</code>, abort all these steps.

            3. If |existingDocumentDefinition| and |documentDefinition| are not equivalent, (that is
                <a for="document layout definition">input properties</a>, <a for="document layout
                definition">child input properties</a>, and <a for="document layout
                definition">layout options</a> are different), then:

                <a for=map>Set</a> |documentLayoutDefinitionMap|[|name|] to <code>"invalid"</code>.

                Log an error to the debugging console stating that the same class was registered
                with different <code>inputProperties</code>, <code>childInputProperties</code>, or
                <code>layoutOptions</code>.

        4. Otherwise, <a for=map>set</a> |documentLayoutDefinitionMap|[|name|] to
            |documentDefinition|.

<div class='note'>
    Note: The shape of the class should be:
    <pre class='lang-javascript'>
        class MyLayout {
            static get inputProperties() { return ['--foo']; }
            static get childrenInputProperties() { return ['--bar']; }
            static get layoutOptions() {
              return {childDisplay: 'normal', sizing: 'block-like'}
            }

            *intrinsicSizes(children, edges, styleMap) {
                // Intrinsic sizes code goes here.
            }

            *layout(children, edges, constraints, styleMap, breakToken) {
                // Layout code goes here.
            }
        }
    </pre>
</div>
</div>

Layout Engine {#layout-engine}
------------------------------

<pre class="idl">
[Exposed=LayoutWorklet]
interface LayoutFragmentRequest {
  // Has internal slots:
  // [[layoutChild]] - The layout child to generate the fragment for.
  // [[layoutConstraints]] - The layout constraints object to perform layout in.
  // [[breakToken]] - The break token to resume the layout with.
};

[Exposed=LayoutWorklet]
interface IntrinsicSizesRequest {
  // Has internal slots:
  // [[layoutChild]] - The layout child to calculate the intrinsic sizes for.
};
</pre>

The layout method and intrinsic sizes method on the author supplied layout class is a generator
function instead of a regular javascript function. This is for user-agents to be able to support
asynchronous and parallel layout engines.

When an author invokes the {{LayoutChild/layoutNextFragment()}} method on a {{LayoutChild}} the
user-agent doesn't synchronously generate a {{LayoutFragment}} to return to the author's code.
Instead it returns a {{LayoutFragmentRequest}}. This is a completely opaque object to the author but
contains internal slots which encapsulates the {{LayoutChild/layoutNextFragment()}} method call.

When a {{LayoutFragmentRequest}}(s) are yielded from a layout generator object the user-agent's
layout engine may run the algorithm asynchronously with other work, and/or on a different thread of
execution. When {{LayoutFragment}}(s) have been produced by the engine, the user-agent will "tick"
the generator object with the resulting {{LayoutFragment}}(s).

The same applies for the {{LayoutChild/intrinsicSizes()}} method.

<div class="example">
An example layout engine written in javascript is shown below.

<pre class="lang-javascript">
class LayoutEngine {
  // This function takes the root of the box-tree, a LayoutConstraints object, and a
  // BreakToken to (if paginating for printing for example) and generates a
  // LayoutFragment.
  layoutEntry(rootBox, rootPageConstraints, breakToken) {
    return layoutFragment({
      box: rootBox,
      layoutConstraints: rootPageConstraints,
      breakToken: breakToken,
    });
  }

  // This function takes a LayoutFragmentRequest and calls the appropriate
  // layout algorithm to generate the a LayoutFragment.
  layoutFragment(fragmentRequest) {
    const box = fragmentRequest.layoutChild;
    const algorithm = selectLayoutAlgorithmForBox(box);
    const fragmentRequestGenerator = algorithm.layout(
        fragmentRequest.layoutConstraints,
        box.children,
        box.styleMap,
        fragmentRequest.breakToken);

    let nextFragmentRequest = fragmentRequestGenerator.next();

    while (!nextFragmentRequest.done) {
      // A user-agent may decide to perform layout to generate the fragments in
      // parallel on separate threads. This example performs them synchronously
      // in order.
      let fragments = nextFragmentRequest.value.map(layoutFragment);

      // A user-agent may decide to yield for other work (garbage collection for
      // example) before resuming this layout work. This example just performs
      // layout synchronously without any ability to yield.
      nextFragmentRequest = fragmentRequestGenerator.next(fragments);
    }

    return nextFragmentRequest.value; // Return the final LayoutFragment.
  }
}
</pre>
</div>

Performing Layout {#performing-layout}
--------------------------------------

<pre class='idl'>
// This is the final return value from the author defined layout() method.
dictionary FragmentResultOptions {
    double inlineSize = 0;
    double blockSize = 0;
    sequence&lt;LayoutFragment> childFragments = [];
    any data = null;
    BreakTokenOptions breakToken = null;
};

dictionary IntrinsicSizesResultOptions {
    double maxContentSize;
    double minContentSize;
};

interface IntrinsicSizes {
  readonly attribute double minContentSize;
  readonly attribute double maxContentSize;
};
</pre>

Issue: Should {{IntrinsicSizes/minContentSize}} and {{IntrinsicSizes/maxContentSize}} be content
    contributions instead? E.g.  minContentContribution, maxContentContribution. Should
    {{IntrinsicSizesResultOptions/minContentSize}} and
    {{IntrinsicSizesResultOptions/maxContentSize}} be content contributions as well?

### Determining Intrinsic Sizes ### {#determining-intrinsic-sizes}

The <a>determine the intrinsic sizes</a> algorithm defines how a user agent is to query the author
defined layout for a <a>box's</a> <a>intrinsic sizes</a> information.

Note: The <a>determine the intrinsic sizes</a> algorithm allows for user agents to cache an arbitary
    number of previous invocations to reuse.

<div algorithm="determine the intrinsic sizes">
When the user agent wants to <dfn>determine the intrinsic sizes</dfn> of a <a>layout API formatting
context</a> for a given |box|, |childBoxes| it <em>must</em> run the following steps:

    1. Let |layoutFunction| be the ''layout()'' for the <a>computed value</a> of <<display-inside>>
        for |box|.

    2. If the <a>intrinsic sizes valid flag</a> for the |layoutFunction| is
        <a>intrinsic-sizes-valid</a> the user agent <em>may</em> use the intrinsic sizes from the
        previous invocation. If so it <em>may</em> abort all these steps and use the previous value
        for the intrinsic sizes.

    3. Set the <a>intrinsic sizes valid flag</a> for the |layoutFunction| to
        <a>intrinsic-sizes-valid</a>.

    4. Let |name| be the first argument of the |layoutFunction|.

    5. Let |documentDefinition| be the result of <a>get a document layout definition</a>.

        If <a>get a document layout definition</a> returned failure, or if |documentDefinition| is
        <code>"invalid"</code>, then let |box| fallback to the <a>flow layout</a> and abort all
        these steps.

    6. Let |workletGlobalScope| be a {{LayoutWorkletGlobalScope}} from the list of <a>worklet's
        WorkletGlobalScopes</a> from the layout {{Worklet}}.

        The user agent <em>must</em> have, and select from at least two
        {{LayoutWorkletGlobalScope}}s in the <a>worklet's WorkletGlobalScopes</a> <a>list</a>,
        unless the user agent is under memory constraints.

        Note: This is to ensure that authers do not rely on being able to store state on the global
            object or non-regeneratable state on the class.

        The user agent <em>may</em> also <a>create a WorkletGlobalScope</a> at this time, given the
        layout {{Worklet}}.

    7. Run <a>invoke a intrinsic sizes callback</a> given |name|, |box|, |childBoxes|, and
        |workletGlobalScope| optionally <a>in parallel</a>.

        Note: If the user agent runs <a>invoke a intrinsic sizes callback</a> on a thread <a>in
            parallel</a>, it should select a layout worklet global scope which can be used on that
            thread.
</div>

<div algorithm="invoke a intrinsic sizes callback">
When the user agent wants to <dfn>invoke a intrinsic sizes callback</dfn> given |name|, |box|,
|childBoxes|, and |workletGlobalScope|, it <em>must</em> run the following steps:

    1. Let |definition| be the result of <a>get a layout definition</a> given |name|, and
        |workletGlobalScope|.

        If <a>get a layout definition</a> returned failure, let the |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    2. Let |layoutInstance| be the result of <a>get a layout class instance</a> given |name|, |box|,
        |definition|, |workletGlobalScope|.

        If <a>get a layout class instance</a> returned failure, let the |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    3. Let |inputProperties| be |definition|'s <a for="layout definition">input properties</a>.

    4. Let |childInputProperties| be |definition|'s <a for="layout definition">child input
        properties</a>.

    5. Let |children| be a new <a>list</a> populated with new {{LayoutChild}} objects which
        represent |childBoxes|.

        The {{LayoutChild/styleMap}} on each {{LayoutChild}} should be a new
        {{StylePropertyMapReadOnly}} populated with <em>only</em> the <a>computed values</a> for
        properties listed in |childInputProperties|.

    6. Let |edges| be a new {{LayoutEdgeSizes}} populated with the <a>computed value</a> for all the
        <a>box model edges</a> for |box|.

    7. Let |styleMap| be a new {{StylePropertyMapReadOnly}} populated with <em>only</em> the
        <a>computed values</a> for properties listed in |inputProperties| for |box|.

    8. At this stage the user agent may re-use the <a>intrinsic sizes</a> from a previous invocation
        if |children|, |styleMap| are equivalent to that previous invocation. If so let the
        intrinsic sizes the cached intrinsic sizes and abort all these steps.

    9. Let |intrinsicSizesGeneratorFunction| be |definition|'s <a>intrinsic sizes generator
        function</a>.

    10. Let |intrinsicSizesGenerator| be the result of
        <a>Invoke</a>(|intrinsicSizesGeneratorFunction|, |layoutInstance|, |children|, |edges|,
        |styleMap|).

        If an exception is <a>thrown</a> the let |box| fallback to the <a>flow layout</a> and abort
        all these steps.

    11. Let |intrinsicSizesValue| be the result of <a>run a generator</a> given
        |intrinsicSizesGenerator|, and <code>"intrinsic-sizes"</code>.

        If <a>run a generator</a> returned failure, then let |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    12. Let |intrinsicSizes| be the result of <a>converting</a> |intrinsicSizesValue| to a
        {{IntrinsicSizesResultOptions}}. If an exception is <a>thrown</a>, let |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    13. Set the <a>intrinsic sizes</a> of |box|:

        - Let |intrinsicSizes|'s {{IntrinsicSizesResultOptions/minContentSize}} be the
            <a>min-content size</a> of |box|.

        - Let |intrinsicSizes|'s {{IntrinsicSizesResultOptions/maxContentSize}} be the
            <a>max-content size</a> of |box|.
</div>

### Generating Fragments ### {#generating-fragments}

The <a>generate a fragment</a> algorithm defines how a user agent is to generate a <a>box's</a>
<a>fragment</a> for an author defined layout.

Note: The <a>generate a fragment</a> algorithm allows for user agents to cache an arbitary number of
    previous invocations to reuse.

<div algorithm="generate a fragment">
When the user agent wants to <dfn>generate a fragment</dfn> of a <a>layout API formatting
context</a> for a given |box|, |childBoxes|, |internalLayoutConstraints|, and an optional
|internalBreakToken| it <em>must</em> run the following steps:

    1. Let |layoutFunction| be the ''layout()'' for the <a>computed value</a> of <<display-inside>>
        for |box|.

    2. If the <a>layout valid flag</a> for the |layoutFunction| is <a>layout-valid</a> the user
        agent <em>may</em> use the intrinsic sizes from the previous invocation. If so it
        <em>may</em> abort all these steps and use the previous value for the intrinsic sizes.

    3. Set the <a>layout valid flag</a> for the |layoutFunction| to <a>layout-valid</a>.

    4. Let |name| be the first argument of the |layoutFunction|.

    5. Let |documentDefinition| be the result of <a>get a document layout definition</a>.

        If <a>get a document layout definition</a> returned failure, or if |documentDefinition| is
        <code>"invalid"</code>, then let |box| fallback to the <a>flow layout</a> and abort all
        these steps.

    6. Let |workletGlobalScope| be a {{LayoutWorkletGlobalScope}} from the list of <a>worklet's
        WorkletGlobalScopes</a> from the layout {{Worklet}}.

        The user agent <em>must</em> have, and select from at least two
        {{LayoutWorkletGlobalScope}}s in the <a>worklet's WorkletGlobalScopes</a> <a>list</a>,
        unless the user agent is under memory constraints.

        Note: This is to ensure that authers do not rely on being able to store state on the global
            object or non-regeneratable state on the class.

        The user agent <em>may</em> also <a>create a WorkletGlobalScope</a> at this time, given the
        layout {{Worklet}}.

    7. Run <a>invoke a layout callback</a> given |name|, |box|, |childBoxes|,
        |internalLayoutConstraints|, |internalBreakToken|, and |workletGlobalScope| optionally <a>in
        parallel</a>.

        Note: If the user agent runs <a>invoke a intrinsic sizes callback</a> on a thread <a>in
            parallel</a>, it should select a layout worklet global scope which can be used on that
            thread.
</div>

<div algorithm="invoke a layout callback">
When the user agent wants to <dfn>invoke a layout callback</dfn> given |name|, |box|, |childBoxes|,
|internalLayoutConstraints|, |internalBreakToken|, and |workletGlobalScope|, it <em>must</em> run the
following steps:

    1. Let |definition| be the result of <a>get a layout definition</a> given |name|, and
        |workletGlobalScope|.

        If <a>get a layout definition</a> returned failure, let the |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    2. Let |layoutInstance| be the result of <a>get a layout class instance</a> given |name|, |box|,
        |definition|, |workletGlobalScope|.

        If <a>get a layout class instance</a> returned failure, let the |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    3. Let |inputProperties| be |definition|'s <a for="layout definition">input properties</a>.

    4. Let |childInputProperties| be |definition|'s <a for="layout definition">child input
        properties</a>.

    5. Let |children| be a new <a>list</a> populated with new {{LayoutChild}} objects which
        represent |childBoxes|.

        The {{LayoutChild/styleMap}} on each {{LayoutChild}} should be a new
        {{StylePropertyMapReadOnly}} populated with <em>only</em> the <a>computed values</a> for
        properties listed in |childInputProperties|.

    6. Let |edges| be a new {{LayoutEdgeSizes}} populated with the <a>computed value</a> for all the
        <a>box model edges</a> for |box|.

    7. Let |layoutConstraints| be a new {{LayoutConstraints}} object populated with the appropriate
        information from |internalLayoutConstraints|.

    8. Let |styleMap| be a new {{StylePropertyMapReadOnly}} populated with <em>only</em> the
        <a>computed values</a> for properties listed in |inputProperties| for |box|.

    9. Let |breakToken| be a new {{BreakToken}} populated with the appropriate information from
        |internalBreakToken|.

        If |internalBreakToken| is null, let |breakToken| be null.

    10. At this stage the user agent may re-use a <a>fragment</a> from a previous invocation if
        |children|, |styleMap|, |layoutConstraints|, |breakToken| are equivalent to that previous
        invocation. If so let the fragment output be that cached fragment and abort all these steps.

    11. Let |layoutGeneratorFunction| be |definition|'s <a>layout generator function</a>.

    12. Let |layoutGenerator| be the result of <a>Invoke</a>(|layoutGeneratorFunction|,
        |layoutInstance|, |children|, |edges|, |layoutConstraints|, |styleMap|, |breakToken|).

        If an exception is <a>thrown</a> the let |box| fallback to the <a>flow layout</a> and abort
        all these steps.

    13. Let |fragmentValue| be the result of <a>run a generator</a> given |layoutGenerator|, and
        <code>"layout"</code>.

        If <a>run a generator</a> returned failure, then let |box| fallback to the <a>flow
        layout</a> and abort all these steps.

    14. Let |fragment| be the result of <a>converting</a> |fragmentValue| to a
        {{FragmentResultOptions}}. If an exception is <a>thrown</a>, let |box| fallback to the
        <a>flow layout</a> and abort all these steps.

    15. Create a <a>fragment</a> for |box| with:

        - The <a>inline size</a> set to |fragment|'s {{FragmentResultOptions/inlineSize}}.

        - The <a>block size</a> set to |fragment|'s {{FragmentResultOptions/blockSize}}.

        - The child fragments set to |fragment|'s {{FragmentResultOptions/childFragments}}
            <a>list</a>. The ordering <em>is</em> important as this dictates their paint order
            (described in [[#layout-api-containers]]). Their position relative to the <b>border
            box</b> of the |fragment| should be based off the author specified
            {{LayoutFragment/inlineOffset}} and {{LayoutFragment/blockOffset}}.

        - The <a>fragmentation break</a> information set to |fragment|'s
            {{FragmentResultOptions/breakToken}}.

        - Let |clonedData| be the result of invoking <a>StructuredSerializeForStorage</a> on
            |fragment|'s {{FragmentResultOptions/data}}.

            The user agent must store |clonedData| with the <a>fragment</a>.
</div>

### Utility Algorithms ### {#utility-algorithms}

The section specifies algorithms common to the <a>determine the intrinsic sizes</a> and <a>generate
a fragment</a> algorithms.

<div algorithm="get a document layout definition">
When the user agent wants to <dfn>get a document layout definition</dfn> given |name|, it
<em>must</em> run the following steps:

    1. Let |documentLayoutDefinitionMap| be the associated <a>document's</a> <a>document layout
        definitions</a> map.

    2. If |documentLayoutDefinitionMap|[|name|] does not <a for=map>exist</a>, return failure and
        abort all these steps.

    3. Return the result of <a for=map>get</a> |documentLayoutDefinitionMap|[|name|].
</div>

<div algorithm="get a layout definition">
When the user agent wants to <dfn>get a layout definition</dfn> given |name|, and
|workletGlobalScope|, it <em>must</em> run the following steps:

    1. Let |layoutDefinitionMap| be |workletGlobalScope|'s <a>layout definitions</a> map.

    2. If |layoutDefinitionMap|[|name|] does not <a for=map>exist</a>, run the following steps:

        1. <a>Queue a task</a> to run the following steps:

            1. Let |documentLayoutDefinitionMap| be the associated <a>document's</a> <a>document
                layout definition</a> map.

            2. <a for=map>Set</a> |documentLayoutDefinitionMap|[|name|] to <code>"invalid"</code>.

            3. The user agent <em>should</em> log an error to the debugging console stating that a
                class wasn't registered in all {{LayoutWorkletGlobalScope}}s.

        2. Return failure, and abort all these steps.

    3. Return the result of <a>get</a> |layoutDefinitionMap|[|name|].
</div>

<div algorithm="get a layout class instance">
When the user agent wants to <dfn>get a layout class instance</dfn> given |name|, |box|,
|definition|, and |workletGlobalScope|, it <em>must</em> run the following steps:

    1. Let |layoutClassInstanceMap| be |workletGlobalScope|'s <a>layout class instances</a> map.

    2. Let |key| be a stable <a for=map>key</a> which is unique to |box| and |name|.

    3. Let |layoutInstance| be the result of <a>get</a> |layoutClassInstanceMap|[|key|]. If
        |layoutInstance| is null, run the following steps:

        1. If the <a>constructor valid flag</a> on |definition| is false, let |box| fallback to the
            <a>flow layout</a> and a abort all these steps.

        2. Let |layoutCtor| be the <a>class constructor</a> on |definition|.

        3. Let |layoutInstance| be the result of <a>Construct</a>(|layoutCtor|).

            If <a>construct</a> throws an exception, set the |definition|'s <a>constructor valid
            flag</a> to false, then return failure and abort all these steps.

        4. <a for=map>Set</a> |layoutClassInstanceMap|[|key|] to |layoutInstance|.

    4. Return |layoutInstance|.
</div>

<div algorithm="run a generator">
When the user agent wants to <dfn>run a generator</dfn> given |generator|, and |generatorType|, it
<em>must</em> run the following steps:

    1. Let |nextResult| be the result of calling <a>Invoke</a>(<code>next</code>, |generator|).

        If an exception is <a>thrown</a> return failure, and abort all these steps.

    2. Perform the following substeps until the result of <a>Get</a>(|nextResult|,
        <code>"done"</code>) is <code>true</code>.

        1. Let |requests| be the result of <a>Get</a>(|nextResult|, <code>"value"</code>).

        2. Let |results| be an <a for=list>empty</a> <a>list</a>.

        3. <a for=list>For each</a> |request| in |requests| perform the following substeps:

            1. Let |result| be null.

            2. If |request| is a {{IntrinsicSizesRequest}} then:

                1. Let |layoutChild| be the result of looking up the internal slot
                    <code>\[[layoutChild]]</code> on |request|.

                2. Let |result| be a new {{IntrinsicSizes}} with:

                    - {{IntrinsicSizes/minContentSize}} being |layoutChild|'s <a>min-content
                        size</a>.

                    - {{IntrinsicSizes/maxContentSize}} being |layoutChild|'s <a>max-content
                        size</a>.

            3. If |request| is a {{LayoutFragmentRequest}} and |generatorType| is
                <code>"layout"</code> then:

                1. Let |layoutChild| be result of looking up the internal slot
                    <code>\[[layoutChild]]</code> on |request|.

                2. Let |childLayoutConstraints| be the result of looking up the internal slot
                    <code>\[[childLayoutConstraints]]</code> on |request|.

                3. Let |childBreakToken| be the result of looking up the internal slot
                    <code>\[[childBreakToken]]</code> on |request|.

                4. Let |internalFragment| be the result of the user agent producing a
                    <a>fragment</a> based on |layoutChild|, |childLayoutConstraints|, and
                    |childBreakToken|.

                5. Let |targetRealm| be |generator|'s <a>Realm</a>.

                6. Let |result| be a new {{LayoutFragment}} with:

                    - {{LayoutFragment/inlineSize}} being |internalFragment|'s <a>inline size</a>.

                    - {{LayoutFragment/blockSize}} being |internalFragment|'s <a>block size</a>.

                    - {{LayoutFragment/inlineOffset}} initially set to 0.

                    - {{LayoutFragment/blockOffset}} initially set to 0.

                    - {{LayoutFragment/breakToken}} being a new {{ChildBreakToken}} representing
                        |layoutChild|'s internal break token.

                    - If |internalFragment| has a |clonedData| object stored with it, let
                        {{LayoutFragment/data}} being the result of
                        <a>StructuredDeserialize</a>(|clonedData|, |targetRealm|), otherwise null.

            4. If |result| is null (that is neither of the above branches was taken), return
                failure, and abort all these steps.

            5. <a for=list>Append</a> |result| to |results|.

        The user agent may perform the above loop out of order, and <a>in parallel</a>. The ordering
        for |requests| and |results| however <em>must</em> be consistent.

        Note: This is to allow user agents to run the appropriate layout algorithm on a different
            thread, or asynchronously (e.g. time slicing layout work with other work). If the user
            agent performs the loop in parallel, the outside loop has to wait until all the cross
            thread tasks are complete before calling the generator again. It cannot return partial
            results to the author.

        4. Let |nextResult| be the result of calling <a>Invoke</a>(<code>next</code>,
                |generator|, |results|).

            If an exception is <a>thrown</a> then return failure, and abort all these steps.

    3. Return the result of calling <a>Get</a>(|nextResult|, <code>"value"</code>).
</div>
