<pre class='metadata'>
Title:  CSS Animation Worklet API
Status: ED
Group: houdini
ED: https://drafts.css-houdini.org/css-animation-api-1/
Previous Version:
Shortname: css-animation-api
Level: 1
Abstract:
Editor: Majid Valipour, majidvp@google.com
Editor: Robert Flack, flackr@chromium.org
Editor: Stephen McGruer, smcgruer@chromium.org

</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: NotSupportedError
    urlPrefix: #dfn-;
        text: callback this value
        text: exception
        text: throw
        url: throw; text: thrown
    url: es-invoking-callback-functions; text: Invoke
urlPrefix: https://www.w3.org/TR/css3-transitions/#; type: dfn;
    text: animatable properties
urlPrefix: https://www.w3.org/TR/web-animations/#; type: dfn;
    url: the-documents-default-timeline; text: default document timeline
urlPrefix: https://tc39.github.io/ecma262/#sec-; type: dfn;
    text: constructor
    text: Construct
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: map-objects; text:map object
    url: get-o-p; text: Get
    url: set-o-p-v-throw; text: Set
    url: terms-and-definitions-function; text: function
    urlPrefix: native-error-types-used-in-this-standard-
        text: TypeError
</pre>

<pre class=biblio>
{
    "explainer": {
        "href": "https://github.com/WICG/animation-worklet/blob/gh-pages/README.md",
        "title": "Animation Worklet Explainer",
        "status": "CR",
        "publisher": "WICG",
        "deliveredBy": [
            "https://github.com/WICG/animation-worklet//"
        ]
    }
}
</pre>

Introduction {#intro}
=====================
This document introduces a new primitive for creating scroll-linked and other high performance 
procedural animations on the web. For details on the rational and motivation see [[explainer]].

The <a>Animation Worklet</a> provides a method to create scripted animations that can mutate a set
of user visible animatable attributes. The API is designed to make it possible such animations to
run in performance critical parts of rendering pipeline. Although the specification does not
require certain performance guarantees (e.g., running in sync with every frame produced or in
isolation from main thread) but the API is designed to facilitate and encourage this.


<strong>Relationship to Web Animation API</strong>: Animations running on <a>Animation
Worklet</a> do not necessarily run on main thread and thus are not synchronized with <a>default
document timeline</a>. At the moment we do not expose any API to start, stop, compose or otherwise
control these animations from outside the worklet however our plan is to leverage existing web 
animation APIs such as Element::getAnimations().

Note: <strong>Access to input</strong>: We are interested on exposing additional user input (e.g.,
scrolling input) to these animations so that authors can create jank-free input driven animations
which are not really possible today.


Animation Worklet {#animation-worklet-desc}
==============================
<dfn>Animation Worklet</dfn> is a {{Worklet}} responsible for all classes related to custom
animations. The worklet can be accessed via {{animationWorklet}} attribute.

The {{animationWorklet}}'s <a>worklet global scope type</a> is {{AnimationWorkletGlobalScope}}.

<pre class='idl'>
partial interface Window {
    [SameObject] readonly attribute Worklet animationWorklet;
};
</pre>

<pre class='idl'>
callback VoidFunction = void ();

[Global=(Worklet,AnimationWorklet),Exposed=AnimationWorklet]
interface AnimationWorkletGlobalScope : WorkletGlobalScope {
    void registerAnimator(DOMString name, VoidFunction animatorCtor);
};
</pre>


<div class='note'>
    Note: This is how the class should look.
    <pre class='lang-javascript'>
        class FooAnimator {
            static get inputProperties() { return ['--foo']; }
            static get outputProperties() { return ['transform']; }

            animate(root, children, timeline) {
                // Animation frame logic goes here
            }
        }
    </pre>
</div>



Concepts {#concepts}
====================
A <dfn>animator definition</dfn> describes an author defined animation which can be referenced by
an <a>animator instance</a>. It consists of:

 - A <dfn>class constructor</dfn>.

 - A <dfn>animate function</dfn>.
 
 - A <dfn>animator input property list</dfn>.

 - A <dfn>animator output property list</dfn>.

 - A <dfn>animator root input property list</dfn>.

 - A <dfn>animator root output property list</dfn>.


An <dfn>animator instance</dfn> describes a fully realized custom animation instance in the worklet
context and links an <a>animator definition</a> with the instance specific state such as its element
proxies. It consists of:

 - A <a>animator name</a>.

 - An <a>animation requested flag</a>.

 - A <dfn>root element proxy</dfn>.

 - A list of associated <dfn>children element proxies</dfn>.


An <dfn>element proxy</dfn> defines a handle to an <a>element</a> which can be used to read or
write its explicitly exposed <a>animatable attribute</a>s . It consists of:

 - An <a>animator instance</a>.

 - A <dfn>proxied element</dfn>.

 - A read only map of proxied input properties their values.

 - A map of proxies output properties to their values.

Registering an Animator Definition {#registering-animator-definition}
============================================================
The {{AnimationWorkletGlobalScope}} has a <dfn>animator name to animator definition map</dfn>.
The map gets populated when {{registerAnimator(name, animatorCtor)}} is called.

When the <dfn method for=AnimationWorkletGlobalScope>registerAnimator(|name|,
|animatorCtor|)</dfn> method is called, the user agent <em>must</em> run the following steps:

    1. If the |name| is not a valid <<ident>>, <a>throw</a> a <a>TypeError</a> and abort all these
        steps.

    2. If the |name| exists as a key in the <a>animator name to animator definition map</a>,
        <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.

    3. If the result of <a>IsConstructor</a>(|animatorCtor|) is false, <a>throw</a> a
        <a>TypeError</a> and abort all these steps.

    4. Let |prototype| be the result of <a>Get</a>(|animatorCtor|, "prototype").

    5. If the result of <a>Type</a>(|prototype|) is not Object, <a>throw</a> a <a>TypeError</a>
        and abort all these steps.

    6. Let |animate| be the result of <a>Get</a>(|prototype|, "animate").

    7. If the result of <a>IsCallable</a>(|animate|) is false, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    8. Let |inputProperties| be the result of <a>parsing a property list</a> with name
        "inputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception and
        abort all these steps.

    9. Let |outputProperties| be the result of <a>parsing a property list</a> with name
        "outputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception and
        abort all these steps.

    10. Let |rootInputProperties| be the result of <a>parsing a property list</a> with name
        "rootInputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception
        and abort all these steps.

    11. Let |rootOutputProperties| be the result of <a>parsing a property list</a> with name
        "rootOutputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception
        and abort all these steps.


    12. Let |definition| be a new <a>animator definition</a> with:

        - <a>animator name</a> being |name|

        - <a>class constructor</a> being |animatorCtor|

        - <a>animate function</a> being |animate|

        - <a>animator input property list</a> being |inputProperties|

        - <a>animator input property list</a> being |outputProperties|

        - <a>animator root input property list</a> being |rootInputProperties|

        - <a>animator root output property list</a> being |rootOutputProperties|


    13. Add the key-value pair (|name| - |definition|) to the <a>animator name to animation
        definition map</a> of the associated <a>document</a>.


The {{AnimationWorkletGlobalScope}} has a <dfn>animator name to instance map</dfn>. The map is
populated when the user agent constructs a new <a>animator instance</a>.

When <dfn>parsing a property list</dfn> with name <a>name</a> for <a>animatorCtor</a>, 
the user agent <em>must</em> run the following steps:

    1. Let |properties| be an empty <code>sequence&lt;DOMString></code>

    2. Let |propertiesIterable| be the result of <a>Get</a>(|animatorCtor|, |name|).

    3. If |propertiesIterable| is not undefined, then set |properties| to the result of
        <a>converting</a> |propertiesIterable| to a <code>sequence&lt;DOMString></code>. If an
        exception is thrown, rethrow the exception and abort all these steps.



Creating an Animator {#creating-animator}
====================================================
Each <a>animator instance</a> lives in an {{AnimationWorkletGlobalScope}}. The
<a>animator instance</a> cannot be disposed arbitrarily (e.g., in the middle of running animation
as it may contain the scripted animation state.

The {{AnimationWorkletGlobalScope}} has an <dfn>animator instance list</dfn>. Anytime a new 
<a>animator instance</a> is constructed in that scope, it gets  added to the list.

To <dfn>create a new animator instance</dfn> given |name|, |outside port|, and |workletGlobalScope|,
the user agent <em>must</em> run the following steps:

    1. Let the |definition| be the result of looking up |name| on the |workletGlobalScope|'s
            <a>animator name to animator definition map</a>.

          If |definition| does not exist abort the following steps.

          Issue: We should check the animator instance list to make sure we don't create duplicate
          instances for the same name and element.

    2. Let |animatorCtor| be the <a>class constructor</a> of |definition|.

    3. Let |animatorInstance| be the result of <a>Construct</a>(|animatorCtor|).

          Issue: handle invalid construction.
      
    4. Set the following on |animatorInstance| with:
        - <a>animator name</a> being |name|

        - <a>animation request flag</a> being <a>frame-current</a>

    5. Add |animatorInstance| to <a>animator instance list</a>.


Creating an Element Proxy {#creating-element-proxy}
====================================================
<a>Element Proxy</a> objects are created by the user agent for elements which have either 'animator'
or 'animator-root' CSS properties. They cannot be constructed from user script. A single element may
have multiple <a>Element Proxy</a> objects associated with it; one per <a>animator instance</a>.

The {{ElementProxy}} interface exposes two maps: a read only map of proxied input properties to their
values, and a map of proxied output properties to their values. The input and output properties in
the maps are those specified in <a>registerAnimator</a> for the given <a>animator instance</a>.

<pre class='idl'>
[
    Exposed=(AnimationWorklet),
] interface ElementProxy {
    attribute StylePropertyMapReadOnly inputStyleMap;
    attribute StylePropertyMapReadOnly outputStyleMap;
};
</pre>

Issue: Todo: Should we have NoInterfaceObject/Exposed here? How do we properly represent that this
cannot be constructed via javascript?

Issue: Todo: Need to figure out how we are handling scroll offsets. Previous approach was to have 
mutable offset on each proxy but the new idea is to have readonly ScrollTimeline.

When user agent wants to <dfn>create an element proxy</dfn> given |element|, it
<em>must</em> run the following steps:

    1. Let |animatorInstance| be the <a>animator instance</a> associated with |element|

    2. Let |workletGlobalScope| be the scope associated with |animatorInstance|.

    1. Let |definition| be the result of looking up |name| on the |workletGlobalScope|'s
        <a>animator name to animator definition map</a>.

    2. Let |inputProperties| be <a>animator input property list</a> of |definition|.

    3. Let |proxy| be a new {{ElementProxy}} Object with:

        - <a>proxied element</a> being |element|.

        - <a>outputStyleMap</a> being a new {{StylePropertyMap}}.

    4. <a>update proxy input style map</a> with |proxy| and |inputProperties|.

    5. Associate |proxy| with  |animatorInstance|.

    5. Return proxy.


Note: Writing to the outputStyle map will update the effective value of the used style value of the 
<a>proxied element</a>. This <em>may</em> happen asynchronously.


When the user agent wants to <dfn>update proxy input style map</dfn> given |proxy|, and
|properties|, it <em>must</em> run the following steps:


    1. Let |styleMap| be a new {{StylePropertyMapReadOnly}} populated with <em>only</em> the
        <a>computed value</a> of <a>proxied element</a> for properties listed in |properties|.

    2. Set |proxy|'s inputStyleMap to |styleMap|.


When an element is removed, all proxies of that element are considered to be disconnected.
A disconnected proxy continues to have the last value from the <a>computed value</a>
of the <a>proxied element</a> properties, but setting values on its ouputStyleMap will have no
effect.


Requesting Animation Frames {#requesting-animation-frames}
====================
Each <a>animator instance</a> has an associated <dfn>animation requested flag</dfn>. It must be
either <dfn>frame-requested</dfn>, <dfn>frame-current</dfn>. It is initially set to
<a>frame-current</a>.

When a new element proxy is assigned to or removed from an <a>animator instance</a>, that 
<a>animator instance</a>'s<a>animation requested flag</a> should be set to <a>frame-requested</a>.

When the computed style for an element changes, the user agent <em>must</em> run the following steps:

For each <a>element proxy</a> for that element, perform the following steps:

    1. Let |proxy| be the current <a>element proxy</a> of the element.

    2. Let |animator| be the |proxy|'s assigned animator.

    3. Let |name| be the |animator|'s name.

    4. Let |definition| be the result of looking up |name| on the |workletGlobalScope|'s
        <a>animator name to animator definition map</a>.

    5. Let |inputProperties| be <a>animator input property list</a> of |definition|.

    6. For each property in |inputProperties|, if the property’s computed value has changed, 
        set the <a>animation requested flag</a> on the |animator| to <a>frame-requested</a>.


<a>Running animators</a> sets <a>animation requested flag</a> on animators to 
<a>frame-current</a>.


Issue: Todo: Animators that have Timeline as an explicit input will need to request frame
on every animation frame. Formulate this here.

Running Animators {#running-animators}
======================================================

When a user agent wants to produce a new animation frame, if for any <a>animator instance</a> the
associated <a>animation request flag</a> is <a>frame-requested</a> then the the user agent
<em>must</em> <a>run animators</a> for the current frame.

Note: The user agent is not required to run animations on every frame. It is legal to defer
      <a>generating an animation frame<a> until a later frame. This allow the user agent to
      provide a different service level according to their policy. For example, a user agent
      may choose not to service an animation whose proxies will not be visible within the visual
      viewport on the current frame.


When the user agent wants to <dfn>run animators</dfn>, it <em>must</em> iterates over <a>animator
instance list</a> as |instance|:

  1. If the <a>animation requested flag</a> for the instance is <a>frame-current</a>
        the user agent <em>may</em> abort all the following steps.

  2. Let |name| be the <a>animator name</a> of |instance|.

  3. Let |workletGlobalScope| be a {{AnimationWorkletGlobalScope}} from the list of <a>worklet's
        WorkletGlobalScopes</a> from the animation {{Worklet}}.

  4. Let the |definition| be the result of looking up |name| on the |workletGlobalScope|'s
        <a>animator name to animator definition map</a>.

      If |definition| does not exist abort the following steps.

  5. Let |animatorInstance| be the result of looking up |name| on |workletGlobalScope|'s
        <a>animator name to instance map</a>. If |animatorInstance| is null run the following
        substeps:

        Issue: Todo: Add steps to create new animatorInstance given the animator definition.

  6. Let |animateFunction| be |definition|'s <a>animate function</a>.

  9. Let |timestamp| be a {{DOMHighResTimeStamp}} indicating the current frame start time.

  10. Let |timeline| be a new {{AnimationTimline}} with its "currentTime" set to |timestamp|.

  11. Let |root| be a <a>root element proxy</a> of |instance|.

  12. Let |children| be a <a>children element proxies</a> of |instance|.

  13. <a>Invoke</a> |animateFunction| with arguments «|root|, |children|, |timeline|»,
        and with |animatorInstance| as the <a>callback this value</a>.


Note: Although inefficient, it is legal for the user agent to <a>run animators</a> multiple times 
in the same frame.

Closing an Animator {#closing-animator}
====================================================

Issue: Todo: Define when we may get rid of the animator.


CSS Animator Notation {#css-animator-notation}
==============================================

Two CSS properties 'animator-root' and 'animator' may be used to
assign an HTML elements to an animator instance either as a root element or a child element.


<pre class='propdef'>
Name: animator-root
Value:  [ none |  <<ident>> ]#
Initial: none
Applies to: all elements
Inherited: no
Computed value: as specified
Percentages: N/A
Media: interactive
Animatable: no
</pre>

<dl dfn-type=value dfn-for=animator-root>
    <dt><dfn>none</dfn>
    <dd>
        There will be no animators.
    <dt><dfn><<ident>></dfn>
    <dd>
       If there is a <a>animator definition</a> registered with that name, then a new
       <a>animator instance</a> will be created with this element as its <a>root element proxy</a>.
       The new <a>animator instance</a> lifetime is tied to this root element's lifetime. If no <a>animator
       definition</a> exists with that name, then the instance will be created as soon as one is
       registered.
</dl>



<pre class='propdef'>
Name: animator
Value:  [ none |  <<ident>> ]#
Initial: auto
Applies to: all elements
Inherited: no
Computed value: as specified
Percentages: N/A
Media: interactive
Animatable: no
</pre>


<dl dfn-type=value dfn-for=animator>
    <dt><dfn>none</dfn>
    <dd>
        There will be no animators.
    <dt><dfn><<ident>></dfn>
    <dd>
      If there is a <a>animator definition</a> registered with that name, then this element is
      assigned to the first ancestor animator instance of the given name as a child element proxy.
      If no <a>animator definition</a> exists with that name, then the element gets assigned as soon
      as one is registered.

      Issue: Todo: If no ancestor animator instance exists with that name then we should create one
      with document root element as its root.
</dl>


Note: All the elements in the root element's DOM sub-tree that get associated with the same animator
 name will get assigned to the the animator instance linked with this root element.


Issue: Todo: Write the algorithm for element assignments. It will include construction of a new
{{ElementProxy}}, looking up or creating animator instance, and assigning the animator. We probably
need a diagram here too.


Effect Stack {#effect-stack}
============================

Issue: Todo: the animators output style values have the highest order in animation stack effect and
their composite operation is "replace" which is going to allow them to run independent on other
animations and in a different thread. Supporting other composite operation is not in scope at this
point.



Examples {#examples}
====================

Example 1: A fade-in animation with spring timing. {#example-1}
-----------------------------------------

<pre class='lang-markup'>
.myFadein {
  animator:'spring-fadein';
}

&lt;section class='myFadein'&gt;&lt;/section&gt;
&lt;section class='myFadein' style="--spring-k: 25;"&gt;&lt;/section&gt;

&lt;scriptlt;
document.animationWorklet.import('spring-timing.js');
&lt;/scriptlt;

</pre>

<pre class='lang-javascript'>
// Inside AnimationWorkletGlobalScope
registerAnimator('spring-fadein', class {

    static inputProperties =  ['--spring-k'];
    static outputProperties =  ['opacity'];
    static inputTime = true;

    animate(root, children, timeline) {
        this.startTime_ = this.startTime_ || timeline.currentTime;
        const deltaT = timeline.currentTime - this.startTime_;
        children.forEach(elem => {
          // read a custom css property.
          const k = elem.inputStyleMap.get('--spring-k') || 1;
          // compute progress using a fancy spring timing function.
          const effectiveValue = 1 * springTiming(deltaT, k);
          // update opacity accordingly.
          elem.ouputStyleMap.opacity = effectiveValue;
        });
    }

    springTiming(deltaT, k) {
        // simulate the spring effect and return a progress value between [-1, 1];
    }
});
</pre>
